ufu.cmd.c:  ufu_exec_ext(env,env->viewer,dname,fname);
ufu.cmd.c:  ufu_exec_ext(env,env->editor,dname,fname);
ufu.com.c:    sprintf(env->msg,"Unable to get address for %s!",r->hostname);
ufu.com.c:    sprintf(env->msg,"Unable to open socket to %s on port %d!",r->hostname,r->port);
ufu.com.c:    sprintf(env->msg,"Unable to connect to %s on port %d!",r->hostname,r->port);
ufu.com.c:  sprintf(env->msg,"Connected to %s on port %d.",r->hostname,r->port);
ufu.com.c:    sprintf(env->msg,"Disconnected from %s on port %d.",r->hostname,r->port);
ufu.com.c:      time_inout=env->timein;
ufu.com.c:      time_retry=env->timein_retry;
ufu.com.c:      time_inout=env->timeout;
ufu.com.c:      time_retry=env->timeout_retry;
ufu.com.c:      sprintf(env->msg,"Error in polling!");
ufu.com.c:        sprintf(env->msg,"Timeout in polling! (>%d ms)",time_inout);
ufu.com.c:          sprintf(env->msg,"Retrying poll, left: %d",time_retry-c);
ufu.com.c:          sprintf(env->msg,"Used all the polling retries! (%d)",time_retry);
ufu.com.c:            sprintf(env->msg,"Poll: Error!");
ufu.com.c:            sprintf(env->msg,"Poll: Hang up!");
ufu.com.c:            sprintf(env->msg,"Poll: Invalid request!");
ufu.com.c:          sprintf(env->msg,"[EACCES] No write permission!");
ufu.com.c:          sprintf(env->msg,"[EAGAIN] (Non-)blocking socket issue!");
ufu.com.c:          sprintf(env->msg,"[EBADF] Invalid descriptor!");
ufu.com.c:          sprintf(env->msg,"[ECONNRESET] Connection reset by pear!");
ufu.com.c:          sprintf(env->msg,"[EDESTADDRREQ] No connection!");
ufu.com.c:          sprintf(env->msg,"[EFAULT] Invalid user space address!");
ufu.com.c:          sprintf(env->msg,"[EINTR] Signalled before data transmission!");
ufu.com.c:          sprintf(env->msg,"[EINVAL] Invalid argument!");
ufu.com.c:          sprintf(env->msg,"[EMSGSIZE] Invalid size!");
ufu.com.c:          sprintf(env->msg,"[EISCONN] Already connected!");
ufu.com.c:          sprintf(env->msg,"[ENOBUFS] Output queue is full!");
ufu.com.c:          sprintf(env->msg,"[ENOMEM] Out of memory!");
ufu.com.c:          sprintf(env->msg,"[ENOTCONN] Not connected!");
ufu.com.c:          sprintf(env->msg,"[ENOTSOCK] Argument is not a socket!");
ufu.com.c:          sprintf(env->msg,"[EOPNOTSUPP] Inappropriate flags!");
ufu.com.c:          sprintf(env->msg,"[EPIPE] End socket closed!");
ufu.com.c:          sprintf(env->msg,"Errno %d: Unknow error!",errmsg);
ufu.com.c:          sprintf(env->msg,"[EAGAIN] (Non-)blocking socket issue!");
ufu.com.c:          sprintf(env->msg,"[EBADF] Invalid descriptor!");
ufu.com.c:          sprintf(env->msg,"[ECONNREFUSED] Connection refused!");
ufu.com.c:          sprintf(env->msg,"[EFAULT] Invalid user space address!");
ufu.com.c:          sprintf(env->msg,"[EINTR] Receive interupted!");
ufu.com.c:          sprintf(env->msg,"[EINVAL] Invalid argument!");
ufu.com.c:          sprintf(env->msg,"[ENOMEM] Out of memory!");
ufu.com.c:          sprintf(env->msg,"[ENOTCONN] Socket not connected!");
ufu.com.c:          sprintf(env->msg,"[ENOTSOCK] Argument is not a socket!");
ufu.com.c:          sprintf(env->msg,"Errno %d: Unknow error!",errmsg);
ufu.com.c:  sprintf(env->msg,"%s",env->msg);
ufu.com.func.c:  sprintf(env->msg,"Scrambling password.");
ufu.com.func.c:  if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:    ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:    env->key_add_panel++;
ufu.com.func.c:    sprintf(env->msg,"Remote dir to read: %s",dirname);
ufu.com.func.c:    strcpy(env->panel[p]->dirname,dirname);
ufu.com.func.c:    env->panel[p]->header=UFU_HDR_STD;
ufu.com.func.c:    env->panel[p]->sortc=UFU_SORT_FNAME;
ufu.com.func.c:    env->panel[p]->sorto=UFU_SORT_ASC;
ufu.com.func.c:    env->panel[p]->size=(long) 0;
ufu.com.func.c:    ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:      env->panel[p]->remote=TRUE;
ufu.com.func.c:      env->panel[p]->local=FALSE;
ufu.com.func.c:      strcpy(env->panel[p]->nodename,env->panel[panel]->rem->hostname);
ufu.com.func.c:      env->panel[p]->first=NULL;
ufu.com.func.c:      env->panel[p]->last=NULL;
ufu.com.func.c:      env->panel[p]->tos=NULL;
ufu.com.func.c:      env->panel[p]->cos=NULL;
ufu.com.func.c:      env->panel[p]->ndirs=0;
ufu.com.func.c:      env->panel[p]->nfiles=0;
ufu.com.func.c:      env->panel[p]->nlinks=0;
ufu.com.func.c:      env->panel[p]->ntotal=0;
ufu.com.func.c:        if(ufu_recv(env,env->panel[panel]->rem,b)) {
ufu.com.func.c:            sprintf(env->msg,"Receiving entry #%d \"%s\".",e1->seqno,e1->fname);
ufu.com.func.c:              env->panel[p]->ndirs=b->e_ndirs;
ufu.com.func.c:              env->panel[p]->nfiles=b->e_nfiles;
ufu.com.func.c:              env->panel[p]->nlinks=b->e_nlinks;
ufu.com.func.c:              env->panel[p]->ntotal=b->e_ntotal;
ufu.com.func.c:              env->panel[p]->size=(long) size;
ufu.com.func.c:              sprintf(env->msg,"Bytes received from daemon: %ld",env->panel[p]->size);
ufu.com.func.c:            if(env->panel[p]->first!=NULL) {
ufu.com.func.c:              env->panel[p]->last=e1;
ufu.com.func.c:              env->panel[p]->first=e1;
ufu.com.func.c:              env->panel[p]->last=e1;
ufu.com.func.c:              env->panel[p]->tos=NULL;
ufu.com.func.c:              env->panel[p]->cos=NULL;
ufu.com.func.c:            ufu_clear_string(env,env->panel[p]->dirname,UFU_LEN_NAME);
ufu.com.func.c:            strcpy(env->msg,b->errmsg);
ufu.com.func.c:          sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_clear_string(env,env->panel[p]->dirname,UFU_LEN_NAME);
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.com.func.c:  if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:    ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:    sprintf(env->msg,"Remote file to read: %s",dirname);
ufu.com.func.c:    strcpy(env->panel[p]->dirname,dirname);
ufu.com.func.c:    ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:      if(ufu_recv(env,env->panel[panel]->rem,b)) {
ufu.com.func.c:            env->panel[p]->size+=(long) b->e_size;
ufu.com.func.c:          sprintf(env->msg,"Receiving entry \"%s\".",e->fname);
ufu.com.func.c:          strcpy(env->msg,b->errmsg);
ufu.com.func.c:        sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.com.func.c:  sprintf(f,"/tmp/ufu.%d.XXXXXX",env->pid);
ufu.com.func.c:  if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:    ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:    sprintf(env->msg,"Remote txtfile to get: %s",fname);
ufu.com.func.c:    ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:            if(ufu_recv(env,env->panel[panel]->rem,b)) {
ufu.com.func.c:                strcpy(env->msg,b->errmsg);
ufu.com.func.c:              sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:          sprintf(env->msg,"%d lines received from daemon.",i);
ufu.com.func.c:                sprintf(env->msg,"%s, shall I try to write this humble file? ",env->master);
ufu.com.func.c:              ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:              if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:                ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:                sprintf(env->msg,"Remote txtfile to put: %s",fname);
ufu.com.func.c:                  ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:                    if(ufu_recv(env,env->panel[panel]->rem,b)) {
ufu.com.func.c:                        sprintf(env->msg,"Reading from file \"%s\".",f);
ufu.com.func.c:                          ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:                        ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:                        sprintf(env->msg,"%d lines send to daemon.",i);
ufu.com.func.c:                        strcpy(env->msg,b->errmsg);
ufu.com.func.c:                      sprintf(env->msg,"Unable to send!");
ufu.com.func.c:                    ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:                    sprintf(env->msg,"Send failed!");
ufu.com.func.c:                  sprintf(env->msg,"(%s) Unable to open temporary file for reading!",fname);
ufu.com.func.c:                sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:                sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.com.func.c:          sprintf(env->msg,"(%s) Unable to open temporary file for writing!",fname);
ufu.com.func.c:        sprintf(env->msg,"(%s) Unable to create temporary file!",fname);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.com.func.c:          sprintf(env->msg,"Receiving daemon version \"%s\".",r->dversion);
ufu.com.func.c:            strcpy(env->msg,"Daemon version seems ok.");
ufu.com.func.c:            strcpy(env->msg,"Difference in client/daemon versions!");
ufu.com.func.c:            sprintf(env->msg,"  Client: %s",UFU_VERSION);
ufu.com.func.c:            sprintf(env->msg,"  Daemon: %s",r->dversion);
ufu.com.func.c:            strcpy(env->msg,"Daemon version differs from client version!");
ufu.com.func.c:          strcpy(env->msg,b->errmsg);
ufu.com.func.c:        sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",r->hostname);
ufu.com.func.c:  sprintf(f,"/tmp/ufu.%d.XXXXXX",env->pid);
ufu.com.func.c:  if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:    ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:    sprintf(env->msg,"Remote binfile to get: %s",fname);
ufu.com.func.c:    ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:            if(ufu_recv_action(env,env->panel[panel]->rem,ba)) {
ufu.com.func.c:                strcpy(env->msg,ba->errmsg);
ufu.com.func.c:              sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:          sprintf(env->msg,"%ld bytes received from daemon.",(long)i*UFU_ACTION_BUFFER);
ufu.com.func.c:          sprintf(env->msg,"(%s) Unable to open temporary file for writing!",fname);
ufu.com.func.c:        sprintf(env->msg,"(%s) Unable to create temporary file!",fname);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.com.func.c:  sprintf(f,"/tmp/ufu.%d.XXXXXX",env->pid);
ufu.com.func.c:  if(ufu_com_init(env,env->panel[panel]->rem)) {
ufu.com.func.c:    ufu_crypt_passwd(env,b,env->panel[panel]->rem);
ufu.com.func.c:    sprintf(env->msg,"Remote binfile to put: %s",fname);
ufu.com.func.c:    ok=ufu_send(env,env->panel[panel]->rem,b);
ufu.com.func.c:            if(ufu_send_action(env,env->panel[panel]->rem,ba)) {
ufu.com.func.c:                strcpy(env->msg,ba->errmsg);
ufu.com.func.c:              sprintf(env->msg,"Something wrong with transfer!");
ufu.com.func.c:          sprintf(env->msg,"%ld bytes received from daemon.",(long)i*UFU_ACTION_BUFFER);
ufu.com.func.c:          sprintf(env->msg,"(%s) Unable to open temporary file for reading!",fname);
ufu.com.func.c:        sprintf(env->msg,"(%s) Unable to open temporary file!",fname);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      ufu_com_exit(env,env->panel[panel]->rem);
ufu.com.func.c:      sprintf(env->msg,"Send failed!");
ufu.com.func.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.com.func.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[panel]->rem->hostname);
ufu.config.c:    strcpy(env->panel[panel]->dirname,env->homedir);
ufu.config.c:    sprintf(env->msg,"Putting HOMEDIR (%s) in panel #%d.",env->panel[panel]->dirname,panel);
ufu.config.c:    env->panel[panel]->local=FALSE;
ufu.config.c:    env->panel[panel]->remote=FALSE;
ufu.config.c:    if(strcmp(env->homedir,env->workdir)!=0) {
ufu.config.c:      strcpy(env->panel[panel]->dirname,env->workdir);
ufu.config.c:      sprintf(env->msg,"Putting WORKDIR (%s) in panel #%d.",env->panel[panel]->dirname,panel);
ufu.config.c:      env->panel[panel]->local=FALSE;
ufu.config.c:      env->panel[panel]->remote=FALSE;
ufu.config.c:              found=(strcmp(env->panel[j]->dirname,argv[i])==0);
ufu.config.c:              strcpy(env->panel[panel]->dirname,argv[i]);
ufu.config.c:              sprintf(env->msg,"Putting arg #%d (%s) in panel #%d.",i,env->panel[panel]->dirname,panel);
ufu.config.c:              env->panel[panel]->local=FALSE;
ufu.config.c:              env->panel[panel]->remote=FALSE;
ufu.config.c:              sprintf(env->msg,"Ignoring arg #%d (%s), unreadable directory!",i,argv[i]);
ufu.config.c:            sprintf(env->msg,"Ignoring arg #%d (%s), already exist in arguments!",i,argv[i]);
ufu.config.c:    if(env->mpanel<panel) {
ufu.config.c:      sprintf(env->msg,"Adjusting max panels from %d to %d.",env->mpanel,panel);
ufu.config.c:      env->mpanel=panel;
ufu.config.c:    sprintf(env->msg,"Created initial usercommand entry.");
ufu.config.c:    sprintf(env->msg,"Created CMD #%02d: %s.",cmd_count,UFU_INITIAL_UCMD);
ufu.config.c:    sprintf(env->msg,"Scanning config (%s)",cfgfile);
ufu.config.c:          env->debug=(tolower(*(line1+6))=='y');
ufu.config.c:          if(env->debug)
ufu.config.c:            sprintf(env->msg," Setting DEBUG to TRUE");
ufu.config.c:            sprintf(env->msg," Setting DEBUG to FALSE");
ufu.config.c:          strcpy(env->editor,line2);
ufu.config.c:          sprintf(env->msg," Found EDITOR (%s).",env->editor);
ufu.config.c:          strcpy(env->viewer,line2);
ufu.config.c:          sprintf(env->msg," Found VIEWER (%s).",env->viewer);
ufu.config.c:          env->mpanel=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found PANELS (%d).",env->mpanel);
ufu.config.c:          if(env->mpanel<UFU_MAX_PANEL_LOW) {
ufu.config.c:            sprintf(env->msg," Setting PANELS to %d.",UFU_MAX_PANEL_LOW);
ufu.config.c:            env->mpanel=UFU_MAX_PANEL_LOW;
ufu.config.c:          if(env->mpanel>UFU_MAX_PANEL) {
ufu.config.c:            sprintf(env->msg," Setting PANELS to %d.",UFU_MAX_PANEL);
ufu.config.c:            env->mpanel=UFU_MAX_PANEL;
ufu.config.c:          env->cfg_rows=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found ROWS (%d).",env->cfg_rows);
ufu.config.c:          env->cfg_cols=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found COLUMNS (%d).",env->cfg_cols);
ufu.config.c:          env->max_to_mark=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found MAX_TO_MARK (%d).",env->max_to_mark);
ufu.config.c:          env->confirmcopy=(tolower(*line2)=='y');
ufu.config.c:          if(env->confirmcopy)
ufu.config.c:            sprintf(env->msg," Setting CONFIRMCOPY to TRUE");
ufu.config.c:            sprintf(env->msg," Setting CONFIRMCOPY to FALSE");
ufu.config.c:          env->confirmmove=(tolower(*line2)=='y');
ufu.config.c:          if(env->confirmmove)
ufu.config.c:            sprintf(env->msg," Setting CONFIRMMOVE to TRUE");
ufu.config.c:            sprintf(env->msg," Setting CONFIRMMOVE to FALSE");
ufu.config.c:          env->confirmremove=(tolower(*line2)=='y');
ufu.config.c:          if(env->confirmremove)
ufu.config.c:            sprintf(env->msg," Setting CONFIRMREMOVE to TRUE");
ufu.config.c:            sprintf(env->msg," Setting CONFIRMREMOVE to FALSE");
ufu.config.c:          env->incsubdir=(tolower(*line2)=='y');
ufu.config.c:          if(env->incsubdir)
ufu.config.c:            sprintf(env->msg," Setting INCSUBDIRS to TRUE");
ufu.config.c:            sprintf(env->msg," Setting INCSUBDIRS to FALSE");
ufu.config.c:          env->ignoreerror=(tolower(*line2)=='y');
ufu.config.c:          if(env->ignoreerror)
ufu.config.c:            sprintf(env->msg," Setting IGNOREERROR to TRUE");
ufu.config.c:            sprintf(env->msg," Setting IGNOREERROR to FALSE");
ufu.config.c:          env->dirfirst=(tolower(*line2)=='y');
ufu.config.c:          if(env->dirfirst)
ufu.config.c:            sprintf(env->msg," Setting DIRFIRST to TRUE");
ufu.config.c:            sprintf(env->msg," Setting DIRFIRST to FALSE");
ufu.config.c:          sprintf(env->msg," Found CMD #%02d: %s.",cmd_count,line2);
ufu.config.c:            sprintf(env->msg," Found REMOTE #%02d: host=%s,port=%d,user=%s.",rem_count,rh->hostname,rh->port,rh->username);
ufu.config.c:          env->history_min=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found MIN HISTORY (%d).",env->history_min);
ufu.config.c:          env->history_max=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found MAX HISTORY (%d).",env->history_max);
ufu.config.c:          env->timeout=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found TIMEOUT (%d).",env->timeout);
ufu.config.c:          env->timeout_retry=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found TIMEOUT_RETRY (%d).",env->timeout_retry);
ufu.config.c:          env->timein=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found TIMEIN (%d).",env->timein);
ufu.config.c:          env->timein_retry=atoi(line2);
ufu.config.c:          sprintf(env->msg," Found TIMEIN_RETRY (%d).",env->timein_retry);
ufu.config.c:          if(panel<env->mpanel) {
ufu.config.c:              env->panel[panel]->header=UFU_HDR_STD;
ufu.config.c:                    env->panel[panel]->header=UFU_HDR_STD;
ufu.config.c:                    env->panel[panel]->header=UFU_HDR_LA;
ufu.config.c:                    env->panel[panel]->header=UFU_HDR_LM;
ufu.config.c:                    env->panel[panel]->header=UFU_HDR_LC;
ufu.config.c:                    env->panel[panel]->sortc=UFU_SORT_FNAME;
ufu.config.c:                    env->panel[panel]->sortc=UFU_SORT_SIZE;
ufu.config.c:                    env->panel[panel]->sortc=UFU_SORT_LA;
ufu.config.c:                    env->panel[panel]->sortc=UFU_SORT_LM;
ufu.config.c:                    env->panel[panel]->sortc=UFU_SORT_LC;
ufu.config.c:                    env->panel[panel]->sorto=UFU_SORT_ASC;
ufu.config.c:                    env->panel[panel]->sorto=UFU_SORT_DSC;
ufu.config.c:              strcpy(env->panel[panel]->dirname,line2+offset);
ufu.config.c:              env->panel[panel]->local=(strcmp(cfgfile,UFU_GLOBAL_CONFIG)!=0);
ufu.config.c:              env->panel[panel]->remote=FALSE;
ufu.config.c:              if(env->panel[panel]->local)
ufu.config.c:                sprintf(env->msg," Found (local) DIR #%02d: %s,%c%c%c for panel #%d.",dir_count,env->panel[panel]->dirname,tolower(hdr),tolower(sortc),tolower(sorto),panel);
ufu.config.c:                sprintf(env->msg," Found (global) DIR #%02d: %s,%c%c%c for panel #%d.",dir_count,env->panel[panel]->dirname,tolower(hdr),tolower(sortc),tolower(sorto),panel);
ufu.config.c:              sprintf(env->msg," Ignoring DIR (%s), unreadable directory!",line2+4);
ufu.config.c:            sprintf(env->msg," Ignoring DIR (%s). No panels left!",env->panel[panel]->dirname);
ufu.config.c:    sprintf(env->msg,"End of scan.");
ufu.config.c:    if(env->mpanel<panel) {
ufu.config.c:      sprintf(env->msg,"Adjusting max panels from %d to %d.",env->mpanel,panel);
ufu.config.c:      env->mpanel=panel;
ufu.config.c:    sprintf(env->msg,"Configfile \"%s\" not found.",cfgfile);
ufu.config.c:  if((fp=fopen(env->cfglocal,"w"))!=NULL) {
ufu.config.c:    sprintf(env->msg,"Start writing config (%s).",env->cfglocal);
ufu.config.c:    sprintf(env->msg,"Writing config (%s)",env->cfglocal);
ufu.config.c:    if(env->debug)
ufu.config.c:    sprintf(line,"EDITOR=%s\n",env->editor);
ufu.config.c:    sprintf(line,"VIEWER=%s\n",env->viewer);
ufu.config.c:    sprintf(line,"HISTORY_MIN=%d\n",env->history_min);
ufu.config.c:    sprintf(line,"HISTORY_MAX=%d\n",env->history_max);
ufu.config.c:    sprintf(line,"PANELS=%d\n",env->mpanel);
ufu.config.c:    sprintf(line,"MAX_TO_MARK=%d\n",env->max_to_mark);
ufu.config.c:    if(env->confirmcopy)
ufu.config.c:    if(env->confirmmove)
ufu.config.c:    if(env->confirmremove)
ufu.config.c:    if(env->incsubdir)
ufu.config.c:    if(env->ignoreerror)
ufu.config.c:    if(env->dirfirst)
ufu.config.c:    sprintf(line,"TIMEOUT=%d\n",env->timeout);
ufu.config.c:    sprintf(line,"TIMEOUT_RETRY=%d\n",env->timeout_retry);
ufu.config.c:    sprintf(line,"TIMEIN=%d\n",env->timein);
ufu.config.c:    sprintf(line,"TIMEIN_RETRY=%d\n",env->timein_retry);
ufu.config.c:    uc=env->ucfirst;
ufu.config.c:        uc=env->ucfirst;
ufu.config.c:    rh=env->rhfirst;
ufu.config.c:        rh=env->rhfirst;
ufu.config.c:    while((p<env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.config.c:      if(env->panel[p]->local) {
ufu.config.c:        sprintf(env->msg," Writing panel #%d (%s).",p,env->panel[p]->dirname);
ufu.config.c:        switch(env->panel[p]->header) {
ufu.config.c:        switch(env->panel[p]->sortc) {
ufu.config.c:        switch(env->panel[p]->sorto) {
ufu.config.c:        sprintf(line,"DIR=%c%c%c:%s\n",hdr,sortc,sorto,env->panel[p]->dirname);
ufu.config.c:        sprintf(env->msg," Skipping global panel #%d (%s).",p,env->panel[p]->dirname);
ufu.config.c:    chmod(env->cfglocal,S_IRUSR|S_IWUSR);
ufu.config.c:    sprintf(env->msg,"Finished writing config (%s).",env->cfglocal);
ufu.config.c:    sprintf(env->msg,"Unable to open configfile \"%s\" for writing!",env->cfglocal);
ufu.config.c:  ufu_wclear(env->top);
ufu.config.c:  mvwprintw(env->top,0,0,"[%s] Show program configuration",env->nodename);
ufu.config.c:  ufu_wrefresh(env->top);
ufu.config.c:  ufu_wclear(env->bottom);
ufu.config.c:  ufu_wrefresh(env->bottom);
ufu.config.c:  ufu_wclear(env->body);
ufu.config.c:  mvwprintw(env->body,row++,col,"Pid          : %d (%d)",env->pid,env->ppid);
ufu.config.c:  mvwprintw(env->body,row++,col,"User         : %s (%d)",env->uname,env->uid);
ufu.config.c:  mvwprintw(env->body,row++,col,"Group        : %s (%d)",env->gname,env->gid);
ufu.config.c:  mvwprintw(env->body,row++,col,"Rows/Columns : %d/%d",env->rows,env->cols);
ufu.config.c:  mvwprintw(env->body,row++,col,"Ext editor   : %s",env->editor);
ufu.config.c:  mvwprintw(env->body,row++,col,"Ext viewer   : %s",env->viewer);
ufu.config.c:  mvwprintw(env->body,row++,col,"Global config: %s",env->cfgglobal);
ufu.config.c:  mvwprintw(env->body,row++,col,"Local config : %s",env->cfglocal);
ufu.config.c:  h=env->hfirst;
ufu.config.c:    mvwprintw(env->body,row++,col,"History min  : %d entries min, %d entries max, %d in use",env->history_min,env->history_max,i);
ufu.config.c:    mvwprintw(env->body,row++,col,"History min  : %d entries min, %d entries max",env->history_min,env->history_max);
ufu.config.c:  m=env->mfirst;
ufu.config.c:    mvwprintw(env->body,row++,col,"Max to mark  : %d entries, %d in use, %d free",env->max_to_mark,i,env->max_to_mark-i);
ufu.config.c:    mvwprintw(env->body,row++,col,"Max to mark  : %d entries",env->max_to_mark);
ufu.config.c:  mvwprintw(env->body,row++,col,"Logfile      : %s",env->logname);
ufu.config.c:  min=(long int)env->panel[UFU_MIN_PANEL]->ntotal;
ufu.config.c:  max=(long int)env->panel[UFU_MIN_PANEL]->ntotal;
ufu.config.c:  while((strlen(env->panel[p]->dirname)>0)&&(p<env->mpanel)) {
ufu.config.c:    total=total+env->panel[p]->ntotal;
ufu.config.c:    if(env->panel[p]->ntotal<min)
ufu.config.c:      min=env->panel[p]->ntotal;
ufu.config.c:    if(env->panel[p]->ntotal>max)
ufu.config.c:      max=env->panel[p]->ntotal;
ufu.config.c:  mvwprintw(env->body,row++,col,"Panels       : %d of %d total",p+1,env->mpanel+1);
ufu.config.c:  mvwprintw(env->body,row++,col,"Entries      : %ld (min %ld,max %ld,avg %ld)",total,min,max,total/p);
ufu.config.c:  if(env->rb) {
ufu.config.c:    mvwprintw(env->body,row++,col,"Recycle path : %s",env->rb_path);
ufu.config.c:    mvwprintw(env->body,row++,col,"Recycle size : %d MBytes max",env->rb_size);
ufu.config.c:  mvwprintw(env->body,row++,col,"Nodename     : %s",env->nodename);
ufu.config.c:  mvwprintw(env->body,row++,col,"Sysname      : %s",env->sysname);
ufu.config.c:  mvwprintw(env->body,row++,col,"Release      : %s",env->release);
ufu.config.c:  ufu_wrefresh(env->body);
ufu.config.c:      ufu_wclear(env->top);
ufu.config.c:      mvwprintw(env->top,0,0,"[%s] Show program configuration (used keys (for your eyes only))",env->nodename);
ufu.config.c:      ufu_wrefresh(env->top);
ufu.config.c:      ufu_wclear(env->bottom);
ufu.config.c:      ufu_wrefresh(env->bottom);
ufu.config.c:      ufu_wclear(env->body);
ufu.config.c:      mvwprintw(env->body,row++,col,"Key          Times used");
ufu.config.c:      mvwprintw(env->body,row++,col,"------------ ----------");
ufu.config.c:      mvwprintw(env->body,row++,col,"Help         %6d",env->key_help);
ufu.config.c:      mvwprintw(env->body,row++,col,"Up           %6d",env->key_up);
ufu.config.c:      mvwprintw(env->body,row++,col,"Down         %6d",env->key_down);
ufu.config.c:      mvwprintw(env->body,row++,col,"Left         %6d",env->key_left);
ufu.config.c:      mvwprintw(env->body,row++,col,"Right        %6d",env->key_right);
ufu.config.c:      mvwprintw(env->body,row++,col,"Prev page    %6d",env->key_prev_page);
ufu.config.c:      mvwprintw(env->body,row++,col,"Next page    %6d",env->key_next_page);
ufu.config.c:      mvwprintw(env->body,row++,col,"Panel        %6d",env->key_panel);
ufu.config.c:      mvwprintw(env->body,row++,col,"Prev panel   %6d",env->key_prev_panel);
ufu.config.c:      mvwprintw(env->body,row++,col,"Next panel   %6d",env->key_next_panel);
ufu.config.c:      mvwprintw(env->body,row++,col,"Updir        %6d",env->key_dir_up);
ufu.config.c:      mvwprintw(env->body,row++,col,"Homedir      %6d",env->key_dir_home);
ufu.config.c:      mvwprintw(env->body,row++,col,"Workdir      %6d",env->key_dir_work);
ufu.config.c:      mvwprintw(env->body,row++,col,"Prevdir      %6d",env->key_dir_prev);
ufu.config.c:      mvwprintw(env->body,row++,col,"Rootdir      %6d",env->key_dir_root);
ufu.config.c:      mvwprintw(env->body,row++,col,"Go           %6d",env->key_go);
ufu.config.c:      mvwprintw(env->body,row++,col,"Setting      %6d",env->key_setting);
ufu.config.c:      mvwprintw(env->body,row++,col,"Key          Times used");
ufu.config.c:      mvwprintw(env->body,row++,col,"------------ ----------");
ufu.config.c:      mvwprintw(env->body,row++,col,"Info         %6d",env->key_info);
ufu.config.c:      mvwprintw(env->body,row++,col,"XInfo        %6d",env->key_xinfo);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config       %6d",env->key_config);
ufu.config.c:      mvwprintw(env->body,row++,col,"Select       %6d",env->key_select);
ufu.config.c:      mvwprintw(env->body,row++,col,"Edit         %6d",env->key_edit);
ufu.config.c:      mvwprintw(env->body,row++,col,"View         %6d",env->key_view);
ufu.config.c:      mvwprintw(env->body,row++,col,"Expunge      %6d",env->key_expunge);
ufu.config.c:      mvwprintw(env->body,row++,col,"Show mark    %6d",env->key_show_mark);
ufu.config.c:      mvwprintw(env->body,row++,col,"Add mark     %6d",env->key_add_mark);
ufu.config.c:      mvwprintw(env->body,row++,col,"Remove mark  %6d",env->key_rem_mark);
ufu.config.c:      mvwprintw(env->body,row++,col,"Add panel    %6d",env->key_add_panel);
ufu.config.c:      mvwprintw(env->body,row++,col,"Remove panel %6d",env->key_rem_panel);
ufu.config.c:      mvwprintw(env->body,row++,col,"Add ucmd     %6d",env->key_add_ucmd);
ufu.config.c:      mvwprintw(env->body,row++,col,"Remove ucmd  %6d",env->key_rem_ucmd);
ufu.config.c:      mvwprintw(env->body,row++,col,"Header       %6d",env->key_header);
ufu.config.c:      mvwprintw(env->body,row++,col,"Sort order   %6d",env->key_sort_order);
ufu.config.c:      mvwprintw(env->body,row++,col,"Sort column  %6d",env->key_sort_col);
ufu.config.c:      mvwprintw(env->body,row++,col,"Key          Times used");
ufu.config.c:      mvwprintw(env->body,row++,col,"------------ ----------");
ufu.config.c:      mvwprintw(env->body,row++,col,"Search       %6d",env->key_search);
ufu.config.c:      ufu_wrefresh(env->body);
ufu.config.c:      ufu_wclear(env->body);
ufu.config.c:      mvwprintw(env->body,row++,col,"Key          Times used");
ufu.config.c:      mvwprintw(env->body,row++,col,"------------ ----------");
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #1    %6d",env->key_config_1);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #2    %6d",env->key_config_2);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #3    %6d",env->key_config_3);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #4    %6d",env->key_config_4);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #5    %6d",env->key_config_5);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #6    %6d",env->key_config_6);
ufu.config.c:      mvwprintw(env->body,row++,col,"Config #7    %6d",env->key_config_7);
ufu.config.c:      mvwprintw(env->body,row++,col,"Key          Times used");
ufu.config.c:      mvwprintw(env->body,row++,col,"------------ ----------");
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #0 %6d",env->key_ucmd_0);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #1 %6d",env->key_ucmd_1);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #2 %6d",env->key_ucmd_2);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #3 %6d",env->key_ucmd_3);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #4 %6d",env->key_ucmd_4);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #5 %6d",env->key_ucmd_5);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #6 %6d",env->key_ucmd_6);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #7 %6d",env->key_ucmd_7);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #8 %6d",env->key_ucmd_8);
ufu.config.c:      mvwprintw(env->body,row++,col,"Exec ucmd #9 %6d",env->key_ucmd_9);
ufu.config.c:      ufu_wrefresh(env->body);
ufu.config.c:      h=env->hfirst;
ufu.config.c:        ufu_wclear(env->top);
ufu.config.c:        mvwprintw(env->top,0,0,"[%s] Show program history (for your eyes only)",env->nodename);
ufu.config.c:        ufu_wrefresh(env->top);
ufu.config.c:        ufu_wclear(env->bottom);
ufu.config.c:        ufu_wrefresh(env->bottom);
ufu.config.c:          ufu_wclear(env->body);
ufu.config.c:          mvwprintw(env->body,row++,col,"Part        SeqNo Directory");
ufu.config.c:          mvwprintw(env->body,row++,col,"----------- ----- ----------------------------------------------------------");
ufu.config.c:          while((h!=NULL)&&(i<(env->rows-8))) {
ufu.config.c:                mvwprintw(env->body,row,col,"Entry");
ufu.config.c:                mvwprintw(env->body,row,col,"Panel");
ufu.config.c:                mvwprintw(env->body,row,col,"Mark");
ufu.config.c:                mvwprintw(env->body,row,col,"Mark action");
ufu.config.c:                mvwprintw(env->body,row,col,"Usercmd");
ufu.config.c:                mvwprintw(env->body,row,col,"XInfo");
ufu.config.c:                mvwprintw(env->body,row,col,"Remote");
ufu.config.c:                mvwprintw(env->body,row,col,"Setup");
ufu.config.c:                mvwprintw(env->body,row,col,"?");
ufu.config.c:            mvwprintw(env->body,row++,col+12,"%5d %-56s",h->seqno,s);
ufu.config.c:        ufu_wrefresh(env->body);
ufu.config.c:  w=ufu_popup(env,40,menu_max+3,(env->cols-40)/2,(env->rows-(menu_max+5))/2,"Program settings");
ufu.config.c:          if(env->debug)          strcpy(r,yes);
ufu.config.c:          if(env->confirmcopy)    strcpy(r,yes);
ufu.config.c:          if(env->confirmmove)    strcpy(r,yes);
ufu.config.c:          if(env->confirmremove)  strcpy(r,yes);
ufu.config.c:          if(env->ignoreerror)    strcpy(r,yes);
ufu.config.c:          if(env->incsubdir)      strcpy(r,yes);
ufu.config.c:          if(env->dirfirst)       strcpy(r,yes);
ufu.config.c:          if(env->rb)             strcpy(r,yes);
ufu.config.c:            env->debug=!env->debug;
ufu.config.c:            env->confirmcopy=!env->confirmcopy;
ufu.config.c:            env->confirmmove=!env->confirmmove;
ufu.config.c:            env->confirmremove=!env->confirmremove;
ufu.config.c:            env->ignoreerror=!env->ignoreerror;
ufu.config.c:            env->incsubdir=!env->incsubdir;
ufu.config.c:            env->dirfirst=!env->dirfirst;
ufu.config.c:            env->rb=!env->rb;
ufu.config.c:  ufu_wrefresh(env->body);
ufu.curses.c:  env->top=newwin(1,env->cols,0,0);
ufu.curses.c:  env->top_sep=newwin(1,env->cols,1,0);
ufu.curses.c:  env->body=newwin(env->rows-4,env->cols,2,0);
ufu.curses.c:  env->bottom_sep=newwin(1,env->cols,env->rows-2,0);
ufu.curses.c:  env->bottom=newwin(1,env->cols,env->rows-1,0);
ufu.curses.c:  keypad(env->bottom,TRUE);
ufu.curses.c:  delwin(env->top);
ufu.curses.c:  delwin(env->top_sep);
ufu.curses.c:  delwin(env->body);
ufu.curses.c:  delwin(env->bottom_sep);
ufu.curses.c:  delwin(env->bottom);
ufu.curses.c:  ufu_wclear(env->top);
ufu.curses.c:  ufu_wclear(env->body);
ufu.curses.c:  ufu_wclear(env->bottom);
ufu.curses.c:  ufu_wrefresh(env->top);
ufu.curses.c:  ufu_wrefresh(env->body);
ufu.curses.c:  ufu_wrefresh(env->bottom);
ufu.curses.c:  for(i=0;i<env->cols;i++) {
ufu.curses.c:    mvwprintw(env->top_sep,0,i,"=");
ufu.curses.c:    mvwprintw(env->bottom_sep,0,i,"=");
ufu.curses.c:    ufu_wrefresh(env->top_sep);
ufu.curses.c:    ufu_wrefresh(env->bottom_sep);
ufu.curses.c:  ufu_wrefresh(env->body);
ufu.entry.c:  if(strlen(env->panel[p]->dirname)>0) {
ufu.entry.c:    sprintf(env->msg," Reading panel #%d (%s).",p,env->panel[p]->dirname);
ufu.entry.c:    sprintf(env->msg,"Reading panel #%d (%s).",p,env->panel[p]->dirname);
ufu.entry.c:    strcpy(env->panel[p]->info->fname,env->panel[p]->dirname);
ufu.entry.c:    env->panel[p]->first=NULL;
ufu.entry.c:    env->panel[p]->last=NULL;
ufu.entry.c:    if((dirp=opendir(env->panel[p]->dirname))!=NULL) {
ufu.entry.c:        if(env->debug) {
ufu.entry.c:          sprintf(env->msg,"  Reading entry \"%s\".",e->fname);
ufu.entry.c:        if(env->panel[p]->first!=NULL) {
ufu.entry.c:          env->panel[p]->first=e;
ufu.entry.c:          if(S_ISDIR(e->fstat->st_mode))  env->panel[p]->ndirs++;
ufu.entry.c:          if(S_ISREG(e->fstat->st_mode))  env->panel[p]->nfiles++;
ufu.entry.c:          env->panel[p]->ntotal++;
ufu.entry.c:          env->panel[p]->size+=(long) e->fstat->st_size;
ufu.entry.c:          if(S_ISLNK(e->lstat->st_mode))  env->panel[p]->nlinks++;
ufu.entry.c:      env->panel[p]->last=e;
ufu.entry.c:  if(panel<(env->mpanel+1)) {
ufu.entry.c:    ufu_concat_dir(env,f,env->panel[panel]->dirname,e->fname);
ufu.entry.c:    if(panel<(env->mpanel+1)) {
ufu.entry.c:        ufu_concat_dir(env,s,env->panel[panel]->dirname,e->fname);
ufu.entry.c:  ufu_wclear(env->top);
ufu.entry.c:      if(env->panel[p]->remote)
ufu.entry.c:        sprintf(s1,"[%s!%s] FileInfo for marked entry",env->panel[mark->panel]->rem->hostname,env->panel[mark->panel]->rem->username);
ufu.entry.c:        sprintf(s1,"[%s] FileInfo for marked entry",env->nodename);
ufu.entry.c:      if(env->panel[p]->remote)
ufu.entry.c:        sprintf(s1,"[%s!%s] FileInfo for panel entry",env->panel[p]->rem->hostname,env->panel[p]->rem->username);
ufu.entry.c:        sprintf(s1,"[%s] FileInfo for panel entry",env->nodename);
ufu.entry.c:      if(env->panel[p]->remote)
ufu.entry.c:        sprintf(s1,"[%s!%s] FileInfo for entry ",env->panel[p]->rem->hostname,env->panel[p]->rem->username);
ufu.entry.c:        sprintf(s1,"[%s] FileInfo for entry ",env->nodename);
ufu.entry.c:      if(env->panel[p]->remote)
ufu.entry.c:        sprintf(s1,"[%s!%s] FileInfo for (x)entry ",env->panel[p]->rem->hostname,env->panel[p]->rem->username);
ufu.entry.c:        sprintf(s1,"[%s] FileInfo for (x)entry ",env->nodename);
ufu.entry.c:  mvwprintw(env->top,0,0,"%s \"%s\".",s1,s2);
ufu.entry.c:  ufu_wrefresh(env->top);
ufu.entry.c:  ufu_wclear(env->body);
ufu.entry.c:  if(env->panel[p]->remote)
ufu.entry.c:      ufu_resize_string(env,dirname(env->panel[p]->dirname),54,s1);
ufu.entry.c:      ufu_resize_string(env,env->panel[p]->dirname,54,s1);
ufu.entry.c:  mvwprintw(env->body,row++,14,"Directory: %s",s1);
ufu.entry.c:    mvwprintw(env->body,row++,15,"Filename: . (current directory)");
ufu.entry.c:      mvwprintw(env->body,row++,15,"Filename: .. (up directory)");
ufu.entry.c:      mvwprintw(env->body,row++,15,"Filename: %s",s1);
ufu.entry.c:  mvwprintw(env->body,row,15,"Filetype:");
ufu.entry.c:  mvwprintw(env->body,row++,25,s4);
ufu.entry.c:  if(env->panel[p]->remote) {
ufu.entry.c:      mvwprintw(env->body,row++,15,"Links to: %s",s1);
ufu.entry.c:      mvwprintw(env->body,row++,15,"Links to: %s",s1);
ufu.entry.c:  mvwprintw(env->body,row++,19,"Size: %ld bytes (%d blocks, %s)",e->size,e->blocks,s);
ufu.entry.c:    mvwprintw(env->body,row++,13,"Panel size: %ld bytes (%s)",size,s);
ufu.entry.c:    mvwprintw(env->body,row++,13,"Permission: %s [%s]",e->fperm,e->lperm);
ufu.entry.c:    mvwprintw(env->body,row++,13,"Permission: %s",e->fperm);
ufu.entry.c:  mvwprintw(env->body,row++,8,"User permission: %s",s);
ufu.entry.c:  mvwprintw(env->body,row++,7,"Group permission: %s",s);
ufu.entry.c:  mvwprintw(env->body,row++,7,"Other permission: %s",s);
ufu.entry.c:  if(env->panel[p]->remote) {
ufu.entry.c:      mvwprintw(env->body,row++,13,"User/Group: %s [%s] / %s [%s]",e->fusrname,e->lusrname,e->fgrpname,e->lgrpname);
ufu.entry.c:      mvwprintw(env->body,row++,13,"User/Group: %s / %s",e->fusrname,e->fgrpname);
ufu.entry.c:    mvwprintw(env->body,row++,13,"Hard links: %d (%d)",e->links,e->blocks);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Inode: %d [%d]",e->fino,e->lino);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Inode: %d",e->fino);
ufu.entry.c:      mvwprintw(env->body,row++,13,"User/Group: %s [%s] / %s [%s]",ufu_search_user(env,e->fstat->st_uid),ufu_search_user(env,e->lstat->st_uid),ufu_search_group(env,ufu_search_user_gid(env,e->fstat->st_uid)),ufu_search_group(env,ufu_search_user_gid(env,e->lstat->st_uid)));
ufu.entry.c:      mvwprintw(env->body,row++,13,"User/Group: %s / %s",ufu_search_user(env,e->fstat->st_uid),ufu_search_group(env,ufu_search_user_gid(env,e->fstat->st_uid)));
ufu.entry.c:    mvwprintw(env->body,row++,13,"Hard links: %d (%d)",e->fstat->st_nlink,e->fstat->st_blksize);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Inode: %d [%d]",e->fstat->st_ino,e->lstat->st_ino);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Inode: %d",e->fstat->st_ino);
ufu.entry.c:    mvwprintw(env->body,row,12,"Last access: %s",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,50,"[%s]",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,12,"Last access: %s",env->msg);
ufu.entry.c:    mvwprintw(env->body,row,6,"Last modification: %s",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,50,"[%s]",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,6,"Last modification: %s",env->msg);
ufu.entry.c:    mvwprintw(env->body,row,5,"Last status change: %s",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,50,"[%s]",env->msg);
ufu.entry.c:    mvwprintw(env->body,row++,5,"Last status change: %s",env->msg);
ufu.entry.c:      mvwprintw(env->body,row++,12,"Panel/Seqno: %d / %d",mark->panel,mark->seqno);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Level: %d",mark->level);
ufu.entry.c:      if(env->panel[p]->remote) {
ufu.entry.c:        mvwprintw(env->body,row++,2,"Remote daemon version: %s",env->panel[mark->panel]->rem->dversion);
ufu.entry.c:        mvwprintw(env->body,row++,12,"Credentials: %s!%s",env->panel[mark->panel]->rem->hostname,env->panel[mark->panel]->rem->username);
ufu.entry.c:      mvwprintw(env->body,row++,12,"Panel/Seqno: %d / %d",p,e->seqno);
ufu.entry.c:      if(env->panel[p]->remote) {
ufu.entry.c:        mvwprintw(env->body,row++,2,"Remote daemon version: %s",env->panel[p]->rem->dversion);
ufu.entry.c:        mvwprintw(env->body,row++,12,"Credentials: %s!%s",env->panel[p]->rem->hostname,env->panel[p]->rem->username);
ufu.entry.c:      mvwprintw(env->body,row++,18,"Panel: %d",p);
ufu.entry.c:      strcpy(env->panel[p]->dirname,e->fname);
ufu.entry.c:      if(env->panel[p]->remote) {
ufu.entry.c:        mvwprintw(env->body,row++,2,"Remote daemon version: %s",env->panel[p]->rem->dversion);
ufu.entry.c:        mvwprintw(env->body,row++,12,"Credentials: %s!%s",env->panel[p]->rem->hostname,env->panel[p]->rem->username);
ufu.entry.c:  ufu_wrefresh(env->body);
ufu.entry.c:      env->key_xinfo++;
ufu.entry.c:      if(strcmp(env->panel[p]->dirname,"/")!=0) {
ufu.entry.c:            len=strlen(env->panel[p]->dirname)+strlen(e->fname)+1;
ufu.entry.c:            ufu_concat_dir(env,s,env->panel[p]->dirname,e->fname);
ufu.entry.c:            len=strlen(env->panel[p]->dirname);
ufu.entry.c:            strcpy(s,env->panel[p]->dirname);
ufu.entry.c:  ufu_wclear(env->top);
ufu.entry.c:  s2=ufu_alloc_string(env,env->cols+1);
ufu.entry.c:  s3=ufu_alloc_string(env,env->cols+1);
ufu.entry.c:  if(env->panel[panel]->remote)
ufu.entry.c:    sprintf(s2,"[%s!%s] PathInfo for entry ",env->panel[panel]->rem->hostname,env->panel[panel]->rem->username);
ufu.entry.c:    sprintf(s2,"[%s] PathInfo for entry ",env->nodename);
ufu.entry.c:  ufu_resize_string(env,basename(s),env->cols-strlen(s2)-1,s3);
ufu.entry.c:  mvwprintw(env->top,0,0,"%s \"%s\".",s2,s3);
ufu.entry.c:  ufu_wrefresh(env->top);
ufu.entry.c:  sprintf(env->msg,"Start splitting string \"%s\".",s);
ufu.entry.c:    if(env->sfirst!=NULL) {
ufu.entry.c:      env->sfirst=split1;
ufu.entry.c:    sprintf(env->msg,"Found split #%d: \"%s\".",split2->seqno,split2->name);
ufu.entry.c:  sprintf(env->msg,"Finished splitting.");
ufu.entry.c:  ufu_wclear(env->body);
ufu.entry.c:  rows=env->rows-6;
ufu.entry.c:  split1=env->sfirst;
ufu.entry.c:  cos=env->sfirst;
ufu.entry.c:  tos=env->sfirst;
ufu.entry.c:      ufu_wclear(env->body);
ufu.entry.c:      mvwprintw(env->body,0,1,"Lvl Len Split");
ufu.entry.c:      mvwprintw(env->body,1,1,"--- --- ----------------------------------------------------------------------");
ufu.entry.c:        if(split==cos)  wattron(env->body,A_REVERSE);
ufu.entry.c:        mvwprintw(env->body,row,1,"%3d",split->seqno);
ufu.entry.c:        mvwprintw(env->body,row,5,"%3d",strlen(split->name));
ufu.entry.c:        mvwprintw(env->body,row,9,"%-70s",s1);
ufu.entry.c:        if(split==cos)  wattroff(env->body,A_REVERSE);
ufu.entry.c:    ufu_wrefresh(env->body);
ufu.entry.c:        env->key_select++;
ufu.entry.c:        split=env->sfirst;
ufu.entry.c:        ufu_stat_entry(env,env->mpanel+1,e);
ufu.entry.c:        ufu_info_entry(env,e,env->mpanel+1,NULL,NULL,UFU_INFO_XINFO);
ufu.entry.c:        env->key_help++;
ufu.entry.c:        ufu_help(env,env->mpanel+1,UFU_HELP_XINFO);
ufu.entry.c:        env->key_down++;
ufu.entry.c:        env->key_up++;
ufu.entry.c:        env->key_first++;
ufu.entry.c:        tos=env->sfirst;
ufu.entry.c:        cos=env->sfirst;
ufu.entry.c:        env->key_last++;
ufu.entry.c:        env->key_next_page++;
ufu.entry.c:        env->key_prev_page++;
ufu.entry.c:  sprintf(env->msg,"Removing splitted entries.");
ufu.entry.c:  split1=env->sfirst;
ufu.entry.c:    sprintf(env->msg," Removing entry #%d: %s.",split1->seqno,split1->name);
ufu.entry.c:  env->sfirst=NULL;
ufu.entry.c:  sprintf(env->msg,"Finished removing splitted entries.");
ufu.entry.c:  if(env->panel[panel]->remote) {
ufu.entry.c:  width=env->cols;
ufu.entry.c:    if(env->panel[panel]->remote)
ufu.entry.c:      sprintf(s2,"[%s!%s] Panel #%d -",env->panel[panel]->rem->hostname,env->panel[panel]->rem->username,panel); 
ufu.entry.c:      sprintf(s2,"[%s] Panel #%d -",env->panel[panel]->nodename,panel); 
ufu.entry.c:    sprintf(s3,"(%d/%d/%d)",env->panel[panel]->nfiles,env->panel[panel]->ndirs,env->panel[panel]->nlinks);
ufu.entry.c:    ufu_resize_string(env,env->panel[panel]->dirname,env->cols-strlen(s2)-strlen(s3)-5,s4);
ufu.entry.c:    ufu_wclear(env->top);
ufu.entry.c:    mvwprintw(env->top,0,0,"%s %s %s",s2,s4,s3);
ufu.entry.c:    if(env->panel[panel]->sortc==UFU_SORT_FNAME)  sortc='F';
ufu.entry.c:    if(env->panel[panel]->sortc==UFU_SORT_SIZE)   sortc='S';
ufu.entry.c:    if(env->panel[panel]->sortc==UFU_SORT_LA)     sortc='A';
ufu.entry.c:    if(env->panel[panel]->sortc==UFU_SORT_LM)     sortc='M';
ufu.entry.c:    if(env->panel[panel]->sortc==UFU_SORT_LC)     sortc='C';
ufu.entry.c:    if(env->panel[panel]->sorto==UFU_SORT_ASC)    sorto='A';
ufu.entry.c:    if(env->panel[panel]->sorto==UFU_SORT_DSC)    sorto='D';
ufu.entry.c:    mvwprintw(env->top,0,width-2,"%c%c",sortc,sorto);
ufu.entry.c:    ufu_wrefresh(env->top);
ufu.entry.c:    ufu_wclear(env->bottom);
ufu.entry.c:    ufu_wrefresh(env->bottom);
ufu.entry.c:    ufu_wclear(env->body);
ufu.entry.c:    mvwprintw(env->body,0,1,"SeqNo");
ufu.entry.c:    mvwprintw(env->body,0,7,"Name");
ufu.entry.c:    mvwprintw(env->body,0,32+(width-UFU_MIN_COLS),"       Size");
ufu.entry.c:    mvwprintw(env->body,0,44+(width-UFU_MIN_COLS),"Permission");
ufu.entry.c:    mvwprintw(env->body,1,1,"-----");
ufu.entry.c:      mvwprintw(env->body,1,7+i,"-");
ufu.entry.c:    mvwprintw(env->body,1,32+(width-UFU_MIN_COLS),"-----------");
ufu.entry.c:    mvwprintw(env->body,1,44+(width-UFU_MIN_COLS),"----------");
ufu.entry.c:    switch(env->panel[panel]->header) {
ufu.entry.c:        mvwprintw(env->body,0,55+(width-UFU_MIN_COLS),"User     Group");
ufu.entry.c:        mvwprintw(env->body,1,55+(width-UFU_MIN_COLS),"-------- --------");
ufu.entry.c:        mvwprintw(env->body,0,55+(width-UFU_MIN_COLS),"Last access");
ufu.entry.c:        mvwprintw(env->body,1,55+(width-UFU_MIN_COLS),"------------------------");
ufu.entry.c:        mvwprintw(env->body,0,55+(width-UFU_MIN_COLS),"Last modification");
ufu.entry.c:        mvwprintw(env->body,1,55+(width-UFU_MIN_COLS),"------------------------");
ufu.entry.c:        mvwprintw(env->body,0,55+(width-UFU_MIN_COLS),"Last status change");
ufu.entry.c:        mvwprintw(env->body,1,55+(width-UFU_MIN_COLS),"------------------------");
ufu.entry.c:    ufu_wrefresh(env->body);
ufu.entry.c:  if(env->panel[panel]->tos!=NULL) {
ufu.entry.c:    e=env->panel[panel]->tos;
ufu.entry.c:    e=env->panel[panel]->first;
ufu.entry.c:    env->panel[panel]->tos=e;
ufu.entry.c:    env->panel[panel]->cos=e;
ufu.entry.c:  rows=env->rows-6;
ufu.entry.c:      if(e==env->panel[panel]->cos)  wattron(env->body,A_REVERSE);
ufu.entry.c:            mvwprintw(env->body,row+1,1,"-> rm");
ufu.entry.c:            mvwprintw(env->body,row+1,1,"-> cp");
ufu.entry.c:            mvwprintw(env->body,row+1,1,"-> mv");
ufu.entry.c:        mvwprintw(env->body,row+1,1,"%5d",e->seqno);
ufu.entry.c:        mvwprintw(env->body,row+1,7,"%-24s",s1);
ufu.entry.c:          mvwprintw(env->body,row+1,i+7," ");
ufu.entry.c:          mvwprintw(env->body,row+1,7,"%-24s",s1);
ufu.entry.c:            mvwprintw(env->body,row+1,i+7," ");
ufu.entry.c:          mvwprintw(env->body,row+1,7,"%s",s1);
ufu.entry.c:            mvwprintw(env->body,row+1,i+7," ");
ufu.entry.c:          mvwprintw(env->body,row+1,6,"r");
ufu.entry.c:          mvwprintw(env->body,row+1,6,"c");
ufu.entry.c:          mvwprintw(env->body,row+1,6,"m");
ufu.entry.c:      if(!(env->panel[panel]->remote)) {
ufu.entry.c:          mvwprintw(env->body,row+1,32+(width-UFU_MIN_COLS),"[   DIR   ]");
ufu.entry.c:          mvwprintw(env->body,row+1,32+(width-UFU_MIN_COLS),"%11ld",e->fstat->st_size);
ufu.entry.c:          mvwprintw(env->body,row+1,44+(width-UFU_MIN_COLS),"%10s",e->lperm);
ufu.entry.c:          mvwprintw(env->body,row+1,44+(width-UFU_MIN_COLS),"%10s",e->fperm);
ufu.entry.c:          mvwprintw(env->body,row+1,32+(width-UFU_MIN_COLS),"[   DIR   ]");
ufu.entry.c:          mvwprintw(env->body,row+1,32+(width-UFU_MIN_COLS),"%11ld",e->size);
ufu.entry.c:          mvwprintw(env->body,row+1,44+(width-UFU_MIN_COLS),"%10s",e->lperm);
ufu.entry.c:          mvwprintw(env->body,row+1,44+(width-UFU_MIN_COLS),"%10s",e->fperm);
ufu.entry.c:      switch(env->panel[panel]->header) {
ufu.entry.c:          if(!(env->panel[panel]->remote)) {
ufu.entry.c:          mvwprintw(env->body,row+1,55+(width-UFU_MIN_COLS),"%-8s",uname);
ufu.entry.c:          mvwprintw(env->body,row+1,64+(width-UFU_MIN_COLS),"%-8s",gname);
ufu.entry.c:          if(!(env->panel[panel]->remote))
ufu.entry.c:          mvwprintw(env->body,row+1,55+(width-UFU_MIN_COLS),"%24s",env->msg);
ufu.entry.c:          if(!(env->panel[panel]->remote))
ufu.entry.c:          mvwprintw(env->body,row+1,55+(width-UFU_MIN_COLS),"%24s",env->msg);
ufu.entry.c:          if(!(env->panel[panel]->remote))
ufu.entry.c:          mvwprintw(env->body,row+1,55+(width-UFU_MIN_COLS),"%24s",env->msg);
ufu.entry.c:      if(e==env->panel[panel]->cos)  wattroff(env->body,A_REVERSE);
ufu.entry.c:  ufu_wrefresh(env->body);
ufu.entry.c:  if(env->panel[panel]->remote) {
ufu.entry.c:  return(env->panel[panel]->cos);
ufu.help.c:  ufu_wclear(env->top);
ufu.help.c:  ufu_wrefresh(env->top);
ufu.help.c:  ufu_wclear(env->bottom);
ufu.help.c:  ufu_wrefresh(env->bottom);
ufu.help.c:  w=ufu_popup(env,env->cols,env->rows-4,col-9,row+1,"HELP");
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for main window",env->nodename);
ufu.help.c:      mvwprintw(w,row++,col,"   %c    - Switch current panel #%d to \"%s\".",UFU_KEY_DIRHOME,panel,env->homedir);
ufu.help.c:      mvwprintw(w,row++,col,"   %c    - Switch current panel #%d to \"%s\".",UFU_KEY_DIRWORK,panel,env->workdir);
ufu.help.c:      if(strlen(env->panel[panel]->dirnameprev)>0) {
ufu.help.c:        mvwprintw(w,row++,col,"   %c    - Switch current panel #%d to \"%s\".",UFU_KEY_PREVDIR,panel,env->panel[panel]->dirnameprev);
ufu.help.c:      if(env->rows<30) {
ufu.help.c:        ufu_wrefresh(env->top);
ufu.help.c:        w=ufu_popup(env,env->cols,env->rows-4,col-9,row+1,"HELP");
ufu.help.c:        mvwprintw(env->top,0,0,"[%s] Help for main window",env->nodename);
ufu.help.c:        ufu_wrefresh(env->top);
ufu.help.c:      mvwprintw(w,row++,col,"   %c    - View logfile \"%s\".",UFU_KEY_LOG,env->logname);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for select panel window",env->nodename);
ufu.help.c:      mvwprintw(w,row++,col,"   %c    - View logfile \"%s\".",UFU_KEY_LOG,env->logname);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for xinfo window",env->nodename);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for select window",env->nodename);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for marked entries",env->nodename);
ufu.help.c:      mvwprintw(w,row++,col,"   %c    - View logfile \"%s\".",UFU_KEY_LOG,env->logname);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for remote entries",env->nodename);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for usercommands",env->nodename);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help for input",env->nodename);
ufu.help.c:      mvwprintw(env->top,0,0,"[%s] Help!",env->nodename);
ufu.help.c:      mvwprintw(w,4,(env->cols-34)/2,"No help defined for this function!");
ufu.help.c:  ufu_wrefresh(env->top);
ufu.help.c:  ufu_wrefresh(env->body);
ufu.hist.c:      h=env->hfirst;
ufu.hist.c:          sprintf(env->msg,"Updated ENTRY (%d/%d) seqno (%d) to %d for directory \"%s\".",count,env->history_max,h->seqno,seqno,h->dname);
ufu.hist.c:        sprintf(env->msg,"Adding ENTRY (%d/%d) seqno %d for directory \"%s\".",count+1,env->history_max,seqno,dname);
ufu.hist.c:        if(env->hfirst!=NULL) {
ufu.hist.c:          h1=env->hfirst;
ufu.hist.c:          env->hfirst=h;
ufu.hist.c:      env->hist_panel=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding PANEL seqno %d to history.",env->hist_panel);
ufu.hist.c:      env->hist_mark=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding MARK seqno %d to history.",env->hist_mark);
ufu.hist.c:      env->hist_mark_action=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding MARK_ACTION seqno %d to history.",env->hist_mark_action);
ufu.hist.c:      env->hist_ucmd=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding UCMD seqno %d to history.",env->hist_ucmd);
ufu.hist.c:      env->hist_xinfo=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding XINFO seqno %d to history.",env->hist_xinfo);
ufu.hist.c:      env->hist_remote=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding REMOTE seqno %d to history.",env->hist_remote);
ufu.hist.c:      env->hist_setup=seqno;
ufu.hist.c:      sprintf(env->msg,"Adding SETUP seqno %d to history.",env->hist_setup);
ufu.hist.c:      h=env->hfirst;
ufu.hist.c:          sprintf(env->msg,"Found ENTRY seqno %d for directory \"%s\".",h->seqno,h->dname);
ufu.hist.c:      seqno=env->hist_panel;
ufu.hist.c:      sprintf(env->msg,"Found PANEL seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_mark;
ufu.hist.c:      sprintf(env->msg,"Found MARK seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_mark_action;
ufu.hist.c:      sprintf(env->msg,"Found MARK_ACTION seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_ucmd;
ufu.hist.c:      sprintf(env->msg,"Found UCMD seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_xinfo;
ufu.hist.c:      sprintf(env->msg,"Found XINFO seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_remote;
ufu.hist.c:      sprintf(env->msg,"Found REMOTE seqno %d.",seqno);
ufu.hist.c:      seqno=env->hist_setup;
ufu.hist.c:      sprintf(env->msg,"Found SETUP seqno %d.",seqno);
ufu.hist.c:  h=env->hfirst;
ufu.hist.c:  sum=total-(env->history_min);
ufu.hist.c:  sprintf(env->msg,"Retained history: %d/%d (%d).",env->history_min,env->history_max,total);
ufu.hist.c:  if(total>env->history_max) {
ufu.hist.c:    sprintf(env->msg,"Clean up history: E=%d, P=%d, Total=%d.",n_entry,n_panel,total);
ufu.hist.c:    sprintf(env->msg,"Total (%d) > History (%d/%d).",total,env->history_min,env->history_max);
ufu.hist.c:      sprintf(env->msg,"Going to clean %d entries.",sum);
ufu.hist.c:      sprintf(env->msg,"Going to clean 1 entry.");
ufu.hist.c:    while(total>env->history_min) {
ufu.hist.c:      h1=env->hfirst;
ufu.hist.c:      h2=env->hfirst->next;
ufu.hist.c:      env->hfirst=h2;
ufu.hist.c:      sprintf(env->msg,"Cleaned %d entries.",count);
ufu.hist.c:      sprintf(env->msg,"Cleaned 1 entry.");
ufu.hist.c:    sprintf(env->msg,"List of retained history:");
ufu.hist.c:    h=env->hfirst;
ufu.hist.c:      sprintf(env->msg,"%4d [%c] %s -> %d.",i++,h->what,h->dname,h->seqno);
ufu.hist.c:    sprintf(env->msg,"End list.");
ufu.id.c:    sprintf(env->msg,"Scanning users (%s)",UFU_USR_FILE);
ufu.id.c:        sprintf(env->msg,"Unable to read entry for user %s!",u->uname);
ufu.id.c:      sprintf(env->msg,"Found user \"%s\" (uid %d,gid %d)",u->uname,u->uid,u->gid);
ufu.id.c:        env->ufirst=u;
ufu.id.c:    sprintf(env->msg,"Read %d users.",c);
ufu.id.c:    sprintf(env->msg,"Unable to open file %s!",UFU_USR_FILE);
ufu.id.c:    sprintf(env->msg,"Scanning groups (%s)",UFU_GRP_FILE);
ufu.id.c:        sprintf(env->msg,"Unable to read entry for group %s!",g->gname);
ufu.id.c:      sprintf(env->msg,"Found group \"%s\" (gid %d)",g->gname,g->gid);
ufu.id.c:        env->gfirst=g;
ufu.id.c:    sprintf(env->msg,"Read %d groups.",c);
ufu.id.c:    sprintf(env->msg,"Unable to open file %s!",UFU_GRP_FILE);
ufu.id.c:  sprintf(env->msg," Releasing users");
ufu.id.c:  u=env->ufirst;
ufu.id.c:    if(env->debug) {
ufu.id.c:      sprintf(env->msg,"  Releasing user \"%s\" (uid %d,gid %d)",u->uname,u->uid,u->gid);
ufu.id.c:  env->ufirst=NULL;
ufu.id.c:  sprintf(env->msg," Released %d users.",c);
ufu.id.c:  sprintf(env->msg," Releasing groups");
ufu.id.c:  g=env->gfirst;
ufu.id.c:    if(env->debug) {
ufu.id.c:      sprintf(env->msg,"  Releasing group \"%s\" (gid %d)",g->gname,g->gid);
ufu.id.c:  env->gfirst=NULL;
ufu.id.c:  sprintf(env->msg," Released %d groups.",c);
ufu.id.c:  u=env->ufirst;
ufu.id.c:      if(env->debug) {
ufu.id.c:        sprintf(env->msg,"Found username \"%s\" for uid %d.",u->uname,uid);
ufu.id.c:  sprintf(env->msg," No match for uid %d!",uid);
ufu.id.c:  u=env->ufirst;
ufu.id.c:      if(env->debug) {
ufu.id.c:        sprintf(env->msg,"Found gid %d for uid %d.",u->gid,uid);
ufu.id.c:  sprintf(env->msg," No match for gid %d!",u->gid);
ufu.id.c:  g=env->gfirst;
ufu.id.c:      if(env->debug) {
ufu.id.c:        sprintf(env->msg,"Found groupname \"%s\" for gid %d.",g->gname,gid);
ufu.id.c:  sprintf(env->msg," No match for gid %d!",gid);
ufu.id.c:  u=env->ufirst;
ufu.id.c:      if(env->debug) {
ufu.id.c:        sprintf(env->msg,"Found uid %d for username \"%s\".",u->uid,uname);
ufu.id.c:  sprintf(env->msg," No match for username \"%s\"!",uname);
ufu.id.c:  g=env->gfirst;
ufu.id.c:      if(env->debug) {
ufu.id.c:        sprintf(env->msg,"Found gid %d for groupname \"%s\".",g->gid,gname);
ufu.id.c:  sprintf(env->msg," No match for groupname \"%s\"!",gname);
ufu.log.c:  env->lognamefp=fopen(env->logname,"w");
ufu.log.c:  if(env->lognamefp!=NULL) {
ufu.log.c:    setbuf(env->lognamefp,NULL);
ufu.log.c:    sprintf(env->msg,"Log opened for writing.");
ufu.log.c:    sprintf(env->msg,UFU_VERSION);
ufu.log.c:    sprintf(env->msg,UFU_BUILDDATE);
ufu.log.c:  if(env->lognamefp!=NULL) {
ufu.log.c:    sprintf(env->msg,"Log \"%s\" closed for writing.",env->logname);
ufu.log.c:    fclose(env->lognamefp);
ufu.log.c:    unlink(env->logname);
ufu.log.c:  if(env->lognamefp!=NULL) {
ufu.log.c:    fprintf(env->lognamefp,"%s: %s\n",tstamp,env->msg);
ufu.log.c:    fflush(env->lognamefp);
ufu.logo.c:  row=(env->rows-18)/2-1;
ufu.logo.c:  mvwprintw(env->top,0,(env->cols-20)/2,"an Unix File Utility");
ufu.logo.c:  mvwprintw(env->body,row,(env->cols-10)/2,"Welcome to");
ufu.logo.c:  mvwprintw(env->body,row+2,(env->cols-17)/2,"U   U FFFFF U   U");
ufu.logo.c:  mvwprintw(env->body,row+3,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:  mvwprintw(env->body,row+4,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:  mvwprintw(env->body,row+5,(env->cols-17)/2,"U   U FFF   U   U");
ufu.logo.c:  mvwprintw(env->body,row+6,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:  mvwprintw(env->body,row+7,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:  mvwprintw(env->body,row+8,(env->cols-17)/2," UUU  F      UUU");
ufu.logo.c:  mvwprintw(env->body,row+10,(env->cols-22)/2,"(c) 2006,2007,2008 WNW");
ufu.logo.c:  mvwprintw(env->body,row+12,(env->cols-strlen(s))/2,s);
ufu.logo.c:  mvwprintw(env->body,row+14,(env->cols-strlen(s))/2,s);
ufu.logo.c:  mvwprintw(env->body,row+17,(env->cols-45)/2,"Remember, you can always use '?' to get help!");
ufu.logo.c:  ufu_wrefresh(env->top);
ufu.logo.c:  ufu_wrefresh(env->body);
ufu.logo.c:  sprintf(env->msg,"Press <y> if you want to look at the copyright notice: ");
ufu.logo.c:    mvwprintw(env->top,0,(env->cols-20)/2,"an Unix File Utility");
ufu.logo.c:    mvwprintw(env->body,row,(env->cols-10)/2,"Welcome to");
ufu.logo.c:    mvwprintw(env->body,row+2,(env->cols-17)/2,"U   U FFFFF U   U");
ufu.logo.c:    mvwprintw(env->body,row+3,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:    mvwprintw(env->body,row+4,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:    mvwprintw(env->body,row+5,(env->cols-17)/2,"U   U FFF   U   U");
ufu.logo.c:    mvwprintw(env->body,row+6,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:    mvwprintw(env->body,row+7,(env->cols-17)/2,"U   U F     U   U");
ufu.logo.c:    mvwprintw(env->body,row+8,(env->cols-17)/2," UUU  F      UUU");
ufu.logo.c:    mvwprintw(env->body,row+10,1,"This program is free software: you can redistribute it and/or modify it under ");
ufu.logo.c:    mvwprintw(env->body,row+11,1,"the terms of the GNU General Public License as published by the Free Software");
ufu.logo.c:    mvwprintw(env->body,row+12,1,"Foundation, either version 3 of the License, or any later version.");
ufu.logo.c:    mvwprintw(env->body,row+14,1,"This program is distributed in the hope that it will be useful, but WITHOUT");
ufu.logo.c:    mvwprintw(env->body,row+15,1,"ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS");
ufu.logo.c:    mvwprintw(env->body,row+16,1,"FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.");
ufu.logo.c:    ufu_wrefresh(env->top);
ufu.logo.c:    ufu_wrefresh(env->body);
ufu.main.c:  rows=env->rows-6;
ufu.main.c:        sprintf(env->msg,"%s, are you sure to quit this humble executable? ",env->master);
ufu.main.c:        env->key_help++;
ufu.main.c:        env->key_info++;
ufu.main.c:        env->key_down++;
ufu.main.c:          seq_tos=env->panel[panel]->tos->seqno;
ufu.main.c:          env->panel[panel]->cos=env->panel[panel]->cos->next;
ufu.main.c:          if(env->panel[panel]->cos->seqno>seq_bos) {
ufu.main.c:            env->panel[panel]->tos=env->panel[panel]->cos;
ufu.main.c:        env->key_up++;
ufu.main.c:          seq_tos=env->panel[panel]->tos->seqno;
ufu.main.c:          env->panel[panel]->cos=env->panel[panel]->cos->prev;
ufu.main.c:          if(env->panel[panel]->cos->seqno<seq_tos) {
ufu.main.c:            while((i<rows)&&(env->panel[panel]->tos->prev!=NULL)) {
ufu.main.c:              env->panel[panel]->tos=env->panel[panel]->tos->prev;
ufu.main.c:        env->key_first++;
ufu.main.c:        env->panel[panel]->tos=env->panel[panel]->first;
ufu.main.c:        env->panel[panel]->cos=env->panel[panel]->first;
ufu.main.c:        if(env->panel[panel]->cos->next->next!=NULL) {
ufu.main.c:          env->panel[panel]->cos=env->panel[panel]->cos->next->next;
ufu.main.c:        env->key_last++;
ufu.main.c:        env->panel[panel]->cos=cos;
ufu.main.c:        env->panel[panel]->tos=cos;
ufu.main.c:        while((i<(rows-1))&&(env->panel[panel]->tos->prev!=NULL)) {
ufu.main.c:          env->panel[panel]->tos=env->panel[panel]->tos->prev;
ufu.main.c:        env->key_next_page++;
ufu.main.c:        tos=env->panel[panel]->tos;
ufu.main.c:          env->panel[panel]->tos=tos;
ufu.main.c:          env->panel[panel]->cos=tos;
ufu.main.c:        env->key_prev_page++;
ufu.main.c:        while((i<rows)&&(env->panel[panel]->tos->prev!=NULL)) {
ufu.main.c:          env->panel[panel]->tos=env->panel[panel]->tos->prev;
ufu.main.c:        env->panel[panel]->cos=env->panel[panel]->tos;
ufu.main.c:        env->key_dir_home++;
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        if(!(env->panel[panel]->remote)) {
ufu.main.c:          ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:          header=env->panel[panel]->header;
ufu.main.c:          sortc=env->panel[panel]->sortc;
ufu.main.c:          sorto=env->panel[panel]->sorto;
ufu.main.c:          strcpy(dname,env->homedir);
ufu.main.c:          strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:          env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:          strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:          strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:          env->panel[panel]->header=header;
ufu.main.c:          env->panel[panel]->sortc=sortc;
ufu.main.c:          env->panel[panel]->sorto=sorto;
ufu.main.c:          seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:          sprintf(env->msg,"Not allowed for remote panels!");
ufu.main.c:        env->key_dir_work++;
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        if(!(env->panel[panel]->remote)) {
ufu.main.c:          ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:          header=env->panel[panel]->header;
ufu.main.c:          sortc=env->panel[panel]->sortc;
ufu.main.c:          sorto=env->panel[panel]->sorto;
ufu.main.c:          strcpy(dname,env->workdir);
ufu.main.c:          strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:          env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:          strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:          strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:          env->panel[panel]->header=header;
ufu.main.c:          env->panel[panel]->sortc=sortc;
ufu.main.c:          env->panel[panel]->sorto=sorto;
ufu.main.c:          seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:          sprintf(env->msg,"Not allowed for remote panels!");
ufu.main.c:        env->key_dir_root++;
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:        header=env->panel[panel]->header;
ufu.main.c:        sortc=env->panel[panel]->sortc;
ufu.main.c:        sorto=env->panel[panel]->sorto;
ufu.main.c:        strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:        local=env->panel[panel]->local;
ufu.main.c:        remote=env->panel[panel]->remote;
ufu.main.c:          r=env->panel[panel]->rem;
ufu.main.c:        env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:        strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:        strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:          env->panel[panel]->remote=remote;
ufu.main.c:          env->panel[panel]->rem=r;
ufu.main.c:          env->panel[panel]->local=FALSE;
ufu.main.c:          ufu_com_read_dir(env,env->panel[panel]->dirname,panel);
ufu.main.c:          env->panel[panel]->remote=FALSE;
ufu.main.c:          env->panel[panel]->rem=NULL;
ufu.main.c:          env->panel[panel]->local=local;
ufu.main.c:        env->panel[panel]->header=header;
ufu.main.c:        env->panel[panel]->sortc=sortc;
ufu.main.c:        env->panel[panel]->sorto=sorto;
ufu.main.c:        seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:        env->key_dir_up++;
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:        header=env->panel[panel]->header;
ufu.main.c:        sortc=env->panel[panel]->sortc;
ufu.main.c:        sorto=env->panel[panel]->sorto;
ufu.main.c:        strcpy(tmp_dname,env->panel[panel]->dirname);
ufu.main.c:        strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:          strcpy(dname,env->panel[panel]->dirname);
ufu.main.c:        local=env->panel[panel]->local;
ufu.main.c:        remote=env->panel[panel]->remote;
ufu.main.c:          r=env->panel[panel]->rem;
ufu.main.c:        env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:        strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:          env->panel[panel]->remote=remote;
ufu.main.c:          env->panel[panel]->rem=r;
ufu.main.c:          env->panel[panel]->local=FALSE;
ufu.main.c:          ufu_com_read_dir(env,env->panel[panel]->dirname,panel);
ufu.main.c:          env->panel[panel]->remote=FALSE;
ufu.main.c:          env->panel[panel]->rem=NULL;
ufu.main.c:          env->panel[panel]->local=local;
ufu.main.c:        if(env->panel[panel]->ntotal==0) {
ufu.main.c:          env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:          strcpy(env->panel[panel]->dirname,tmp_dname);
ufu.main.c:          strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:        env->panel[panel]->header=header;
ufu.main.c:        env->panel[panel]->sortc=sortc;
ufu.main.c:        env->panel[panel]->sorto=sorto;
ufu.main.c:        seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:        env->key_dir_prev++;
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        if(strlen(env->panel[panel]->dirnameprev)>0) {
ufu.main.c:          ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:          header=env->panel[panel]->header;
ufu.main.c:          sortc=env->panel[panel]->sortc;
ufu.main.c:          sorto=env->panel[panel]->sorto;
ufu.main.c:          strcpy(dname,env->panel[panel]->dirnameprev);
ufu.main.c:          strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:          local=env->panel[panel]->local;
ufu.main.c:          remote=env->panel[panel]->remote;
ufu.main.c:            r=env->panel[panel]->rem;
ufu.main.c:          env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:          strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:          strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:            env->panel[panel]->remote=remote;
ufu.main.c:            env->panel[panel]->rem=r;
ufu.main.c:            env->panel[panel]->local=FALSE;
ufu.main.c:            ufu_com_read_dir(env,env->panel[panel]->dirname,panel);
ufu.main.c:            env->panel[panel]->remote=FALSE;
ufu.main.c:            env->panel[panel]->rem=NULL;
ufu.main.c:            env->panel[panel]->local=local;
ufu.main.c:          env->panel[panel]->header=header;
ufu.main.c:          env->panel[panel]->sortc=sortc;
ufu.main.c:          env->panel[panel]->sorto=sorto;
ufu.main.c:          seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.main.c:        if(env->panel[panel]->remote)
ufu.main.c:          env->key_select++;
ufu.main.c:          ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:          header=env->panel[panel]->header;
ufu.main.c:          sortc=env->panel[panel]->sortc;
ufu.main.c:          sorto=env->panel[panel]->sorto;
ufu.main.c:          local=env->panel[panel]->local;
ufu.main.c:          remote=env->panel[panel]->remote;
ufu.main.c:            r=env->panel[panel]->rem;
ufu.main.c:          strcpy(tmp_dname,env->panel[panel]->dirname);
ufu.main.c:          strcpy(pname,env->panel[panel]->dirname);
ufu.main.c:            strcpy(dname,env->panel[panel]->dirname);
ufu.main.c:                strcpy(dname,env->panel[panel]->dirname);
ufu.main.c:              if(env->panel[panel]->remote)
ufu.main.c:                  strcpy(dname,env->panel[panel]->dirname);
ufu.main.c:                strcpy(dname,env->panel[panel]->dirname);
ufu.main.c:          env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:          strcpy(env->panel[panel]->dirname,dname);
ufu.main.c:          env->panel[panel]->remote=remote;
ufu.main.c:            env->panel[panel]->remote=remote;
ufu.main.c:            env->panel[panel]->rem=r;
ufu.main.c:            env->panel[panel]->local=FALSE;
ufu.main.c:            ufu_com_read_dir(env,env->panel[panel]->dirname,panel);
ufu.main.c:            env->panel[panel]->remote=FALSE;
ufu.main.c:            env->panel[panel]->rem=NULL;
ufu.main.c:            env->panel[panel]->local=local;
ufu.main.c:          if(env->panel[panel]->ntotal==0) {
ufu.main.c:            local=env->panel[panel]->local;
ufu.main.c:            remote=env->panel[panel]->remote;
ufu.main.c:              r=env->panel[panel]->rem;
ufu.main.c:            env->panel[panel]=ufu_alloc_panel(env,panel);
ufu.main.c:            strcpy(env->panel[panel]->dirname,tmp_dname);
ufu.main.c:              env->panel[panel]->remote=remote;
ufu.main.c:              env->panel[panel]->rem=r;
ufu.main.c:              env->panel[panel]->local=FALSE;
ufu.main.c:              ufu_com_read_dir(env,env->panel[panel]->dirname,panel);
ufu.main.c:              env->panel[panel]->remote=FALSE;
ufu.main.c:              env->panel[panel]->rem=NULL;
ufu.main.c:              env->panel[panel]->local=local;
ufu.main.c:            strcpy(env->panel[panel]->dirnameprev,pname);
ufu.main.c:          env->panel[panel]->header=header;
ufu.main.c:          env->panel[panel]->sortc=sortc;
ufu.main.c:          env->panel[panel]->sorto=sorto;
ufu.main.c:          seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:          env->key_info++;
ufu.main.c:        env->key_panel++;
ufu.main.c:        ufu_add_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname,cos->seqno);
ufu.main.c:        seqno=ufu_find_hist(env,UFU_HIST_ENTRY,env->panel[panel]->dirname);
ufu.main.c:        env->key_header++;
ufu.main.c:        switch(env->panel[panel]->header) {
ufu.main.c:            env->panel[panel]->header=UFU_HDR_LA;
ufu.main.c:            env->panel[panel]->header=UFU_HDR_LM;
ufu.main.c:            env->panel[panel]->header=UFU_HDR_LC;
ufu.main.c:            env->panel[panel]->header=UFU_HDR_STD;
ufu.main.c:        env->key_sort_col++;
ufu.main.c:        switch(env->panel[panel]->sortc) {
ufu.main.c:            env->panel[panel]->sortc=UFU_SORT_SIZE;
ufu.main.c:            env->panel[panel]->sortc=UFU_SORT_LA;
ufu.main.c:            env->panel[panel]->sortc=UFU_SORT_LM;
ufu.main.c:            env->panel[panel]->sortc=UFU_SORT_LC;
ufu.main.c:            env->panel[panel]->sortc=UFU_SORT_FNAME;
ufu.main.c:        env->key_sort_order++;
ufu.main.c:        switch(env->panel[panel]->sorto) {
ufu.main.c:            env->panel[panel]->sorto=UFU_SORT_DSC;
ufu.main.c:            env->panel[panel]->sorto=UFU_SORT_ASC;
ufu.main.c:        env->key_prev_panel++;
ufu.main.c:          panel=env->mpanel;
ufu.main.c:          while(strlen(env->panel[panel]->dirname)==0) {
ufu.main.c:        env->key_next_panel++;
ufu.main.c:        if(panel<env->mpanel) {
ufu.main.c:          if(strlen(env->panel[panel+1]->dirname)>0) {
ufu.main.c:        env->key_show_mark++;
ufu.main.c:        env->key_add_mark++;
ufu.main.c:        tmp_tos=env->panel[panel]->tos;
ufu.main.c:        tmp_cos=env->panel[panel]->cos;
ufu.main.c:        env->panel[panel]->cos=tmp_cos;
ufu.main.c:        env->panel[panel]->tos=tmp_tos;
ufu.main.c:        env->key_config++;
ufu.main.c:        env->key_setting++;
ufu.main.c:        env->key_edit++;
ufu.main.c:        if(env->panel[panel]->remote) {
ufu.main.c:          ufu_com_get_txtfile(env,env->panel[panel]->dirname,cos->fname,panel,UFU_EDIT);
ufu.main.c:          ufu_cmd_edit(env,env->panel[panel]->dirname,cos->fname);
ufu.main.c:        env->key_view++;
ufu.main.c:        if(env->panel[panel]->remote) {
ufu.main.c:          ufu_com_get_txtfile(env,env->panel[panel]->dirname,cos->fname,panel,UFU_VIEW);
ufu.main.c:          ufu_cmd_view(env,env->panel[panel]->dirname,cos->fname);
ufu.main.c:        if(!env->panel[panel]->remote) {
ufu.main.c:        env->key_view++;
ufu.main.c:        ufu_cmd_view(env,env->logname,NULL);
ufu.main.c:        env->key_ucmd_0++;
ufu.main.c:        env->key_ucmd_1++;
ufu.main.c:        env->key_ucmd_2++;
ufu.main.c:        env->key_ucmd_3++;
ufu.main.c:        env->key_ucmd_4++;
ufu.main.c:        env->key_ucmd_5++;
ufu.main.c:        env->key_ucmd_6++;
ufu.main.c:        env->key_ucmd_7++;
ufu.main.c:        env->key_ucmd_8++;
ufu.main.c:        env->key_ucmd_9++;
ufu.main.c:        env->key_go++;
ufu.main.c:        sprintf(env->msg,"%s, enter your seqno:",env->master);
ufu.main.c:        ufu_rl(env,env->bottom,strlen(env->msg)+1,0,TRUE,5,5,inp,TRUE,FALSE);
ufu.main.c:        cos=env->panel[panel]->cos;
ufu.main.c:        tos=env->panel[panel]->tos;
ufu.main.c:        env->key_search++;
ufu.main.c:        sprintf(env->msg,"%s, enter pattern:",env->master);
ufu.main.c:        len=env->cols-strlen(env->msg)-1;
ufu.main.c:        ufu_rl(env,env->bottom,strlen(env->msg)+1,0,TRUE,len-1,len-1,inp,TRUE,FALSE);
ufu.main.c:        env->panel[panel]->cos=cos;
ufu.main.c:        env->panel[panel]->tos=tos;
ufu.main.c:        cos=env->panel[panel]->cos;
ufu.main.c:        tos=env->panel[panel]->tos;
ufu.mark.action.c:    sprintf(env->msg,"No remote panel(s) available!");
ufu.mark.action.c:    w=ufu_popup(env,36,7,(env->cols-36)/2,(env->rows-9)/2,"Select action");
ufu.mark.action.c:              env->key_expunge++;
ufu.mark.action.c:          env->key_help++;
ufu.mark.action.c:    ufu_wrefresh(env->body);
ufu.mark.action.c:      w=ufu_popup(env,36,5,(env->cols-22)/2,(env->rows-7)/2,"Select path for copying files");
ufu.mark.action.c:      w=ufu_popup(env,36,5,(env->cols-22)/2,(env->rows-7)/2,"Select path for moving files");
ufu.mark.action.c:        env->key_help++;
ufu.mark.action.c:  ufu_wrefresh(env->body);
ufu.mark.action.c:      ufu_wrefresh(env->body);
ufu.mark.action.c:  ufu_wrefresh(env->body);
ufu.mark.action.c:    m=env->mfirst;
ufu.mark.action.c:      sprintf(env->msg,"Processing entry \"%s\"...",m->entry->fname);
ufu.mark.action.c:            sprintf(env->msg,"Entry \"%s\" marked as being removed.",m->entry->fname);
ufu.mark.action.c:            sprintf(env->msg,"Entry \"%s\" marked as being copied.",m->entry->fname);
ufu.mark.action.c:            sprintf(env->msg,"Entry \"%s\" marked as being moved.",m->entry->fname);
ufu.mark.action.c:        sprintf(env->msg,"All %d files are %s.",rem_ok,str_action);
ufu.mark.action.c:        sprintf(env->msg,"1 file is %s.",str_action);
ufu.mark.action.c:        sprintf(env->msg,"%d files (of %d) are NOT %s!",rem_error,rem_ok+rem_error,str_action);
ufu.mark.action.c:        sprintf(env->msg,"%d file (of %d) is NOT %s!",rem_error,rem_ok+rem_error,str_action);
ufu.mark.action.c:      env->mlast=m1;
ufu.mark.action.c:    env->mfirst=m2;
ufu.mark.action.c:      env->mlast=m1;
ufu.mark.action.c:  if(ufu_com_init(env,env->panel[m->panel]->rem)) {
ufu.mark.action.c:    ufu_crypt_passwd(env,b,env->panel[m->panel]->rem);
ufu.mark.action.c:      strcpy(b->dirname,env->panel[m->panel]->dirname);
ufu.mark.action.c:      strcpy(b->dirname,env->panel[m->panel]->dirname);
ufu.mark.action.c:    sprintf(env->msg,"Remote file to unlink: %s",f);
ufu.mark.action.c:    ok=ufu_send(env,env->panel[m->panel]->rem,b);
ufu.mark.action.c:      if(ufu_recv(env,env->panel[m->panel]->rem,b)) {
ufu.mark.action.c:          sprintf(env->msg,"Unlink succesfull!");
ufu.mark.action.c:          strcpy(env->msg,b->errmsg);
ufu.mark.action.c:        sprintf(env->msg,"Something wrong with transfer!");
ufu.mark.action.c:      ufu_com_exit(env,env->panel[m->panel]->rem);
ufu.mark.action.c:      ufu_com_exit(env,env->panel[m->panel]->rem);
ufu.mark.action.c:      sprintf(env->msg,"Send failed!");
ufu.mark.action.c:    sprintf(env->msg,"Unable to setup connection!");
ufu.mark.action.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[m->panel]->rem->hostname);
ufu.mark.action.c:  rem_src=env->panel[m->panel]->remote;
ufu.mark.action.c:  rem_dst=env->panel[panel]->remote;
ufu.mark.action.c:  sprintf(env->msg,"Crosschecking marked entries...");
ufu.mark.action.c:  m=env->mfirst;
ufu.mark.action.c:    if(!env->panel[m->panel]->remote) {
ufu.mark.action.c:      strcpy(nodename,env->nodename);
ufu.mark.action.c:      strcpy(username,env->uname);
ufu.mark.action.c:      strcpy(nodename,env->panel[m->panel]->rem->hostname);
ufu.mark.action.c:      strcpy(username,env->panel[m->panel]->rem->username);
ufu.mark.action.c:        sprintf(env->msg,"NO REMOTE CONNECTION (%s@%s) for this %s entry \"%s\"!",username,nodename,s1,m->entry->fname);
ufu.mark.action.c:    sprintf(env->msg,"XChecked marked entries: %d.",total);
ufu.mark.action.c:    sprintf(env->msg,"XChecked marked entries: %d. Failed: %d.",total,failed);
ufu.mark.action.c:  x=env->xfirst;
ufu.mark.action.c:    sprintf(env->msg,"Releasing remote \"%s@%s\".",x->username,x->nodename);
ufu.mark.action.c:  env->xfirst=NULL;
ufu.mark.action.c:  while((p<=UFU_MAX_PANEL)&&(strlen(env->panel[p]->dirname)>0)&&(!found)) {
ufu.mark.action.c:    if(env->panel[p]->rem!=NULL) {
ufu.mark.action.c:      if(strcmp(nodename,env->panel[p]->rem->hostname)==0) {
ufu.mark.action.c:        if(strcmp(username,env->panel[p]->rem->username)==0) {
ufu.mark.action.c:          x=env->xfirst;
ufu.mark.action.c:                sprintf(env->msg,"%s@%s: Setting connection status (CONNECTED).",username,nodename);
ufu.mark.action.c:          if(env->xfirst!=NULL) {
ufu.mark.action.c:            x=env->xfirst;
ufu.mark.action.c:            env->xfirst=ufu_alloc_xcheck(env);
ufu.mark.action.c:            strcpy(env->xfirst->username,username);
ufu.mark.action.c:            strcpy(env->xfirst->nodename,nodename);
ufu.mark.action.c:            env->xfirst->connected=UFU_X_F_C;
ufu.mark.action.c:            return(env->xfirst->connected);
ufu.mark.action.c:          sprintf(env->msg,"%s@%s: Adding connection status (CONNECTED).",username,nodename);
ufu.mark.action.c:    if(env->xfirst!=NULL) {
ufu.mark.action.c:      x=env->xfirst;
ufu.mark.action.c:      env->xfirst=ufu_alloc_xcheck(env);
ufu.mark.action.c:      strcpy(env->xfirst->username,username);
ufu.mark.action.c:      strcpy(env->xfirst->nodename,nodename);
ufu.mark.action.c:      env->xfirst->connected=UFU_X_F_NC;
ufu.mark.action.c:    sprintf(env->msg,"%s@%s: Adding connection status (NOT CONNECTED).",username,nodename);
ufu.mark.action.c:  sprintf(env->msg,"%s@%s: Setting connection status (NOT FOUND).",username,nodename);
ufu.mark.c:    if(env->debug) {
ufu.mark.c:      sprintf(env->msg," Level found for \"%s\": %d",s,level);
ufu.mark.c:  if((env->mlast==NULL)||((env->mlast!=NULL)&&((env->mlast->seqno+1)<env->max_to_mark))) {
ufu.mark.c:    sprintf(env->msg,"Marking... ");
ufu.mark.c:          ufu_mark(env,panel,env->panel[panel]->dirname,cos,&marked);
ufu.mark.c:        sprintf(env->msg,"%s, do you wish to mark this humble directory? ",env->master);
ufu.mark.c:          if(env->panel[panel]->remote) {
ufu.mark.c:            strcpy(dname,env->panel[panel]->dirname);
ufu.mark.c:            ufu_concat_dir(env,abs_name,env->panel[panel]->dirname,cos->fname);
ufu.mark.c:            ufu_concat_dir(env,abs_name,env->panel[panel]->dirname,cos->fname);
ufu.mark.c:  if((env->mlast==NULL)||((env->mlast!=NULL)&&((env->mlast->seqno+1)<env->max_to_mark))) {
ufu.mark.c:              if(env->incsubdir) {
ufu.mark.c:    if(env->debug) {
ufu.mark.c:      sprintf(env->msg,"Marking file \"%s\".",abs_name);
ufu.mark.c:    sprintf(env->msg,"Marking file \"%s\" ",abs_name);
ufu.mark.c:    if(env->mfirst==NULL) {
ufu.mark.c:      env->mfirst=m;
ufu.mark.c:      env->mlast=m;
ufu.mark.c:      if((env->mlast==NULL)||((env->mlast!=NULL)&&((env->mlast->seqno+1)<env->max_to_mark))) {
ufu.mark.c:        n=env->mlast;
ufu.mark.c:        env->mlast=m;
ufu.mark.c:        sprintf(env->msg," Ignoring entry \"%s\"!",abs_name);
ufu.mark.c:        sprintf(env->msg," Too many marked entries (>%d)",env->max_to_mark);
ufu.mark.c:    if(env->incsubdir) {
ufu.mark.c:      if((env->mlast==NULL)||((env->mlast!=NULL)&&((env->mlast->seqno+1)<env->max_to_mark))) {
ufu.mark.c:        if(env->panel[panel]->remote) {
ufu.mark.c:            e=env->panel[panel]->first;
ufu.mark.c:                  sprintf(env->msg," Ignoring \"%s\"!",abs_name);
ufu.mark.c:                  sprintf(env->msg," Entering directory \"%s\" recursively.",abs_name);
ufu.mark.c:              ufu_stat_entry(env,env->mpanel+1,e);
ufu.mark.c:                  sprintf(env->msg," Ignoring \"%s\"!",abs_name);
ufu.mark.c:                  sprintf(env->msg," Entering directory \"%s\" recursively.",abs_name);
ufu.mark.c:        sprintf(env->msg," Too many marked entries (>%d)",env->max_to_mark);
ufu.mark.c:  sprintf(env->msg,"Wait while expunging marked entries");
ufu.mark.c:  sprintf(env->msg,"Unmarking file \"%s\" ",m->entry->fname);
ufu.mark.c:    env->mfirst=m->next;
ufu.mark.c:    env->mlast=m->prev;
ufu.mark.c:    sprintf(env->msg,"Rearranging list of marked entries.");
ufu.mark.c:    tmp_m=env->mfirst;
ufu.mark.c:    sprintf(env->msg,"Finished rearranging list of marked entries.");
ufu.mark.c:  m=env->mfirst;
ufu.mark.c:  width=env->cols;
ufu.mark.c:  rows=env->rows-6;
ufu.mark.c:  tos=env->mfirst;
ufu.mark.c:  cos=env->mfirst;
ufu.mark.c:  seqno=env->hist_mark;
ufu.mark.c:  m=env->mfirst;
ufu.mark.c:    m=env->mfirst;
ufu.mark.c:  while((again)&&(env->mfirst!=NULL)) {
ufu.mark.c:      ufu_wclear(env->top);
ufu.mark.c:      mvwprintw(env->top,0,0,"[%s] Show marked entries",env->nodename);
ufu.mark.c:      ufu_wrefresh(env->top);
ufu.mark.c:      ufu_wclear(env->bottom);
ufu.mark.c:      ufu_wrefresh(env->bottom);
ufu.mark.c:      ufu_wclear(env->body);
ufu.mark.c:      mvwprintw(env->body,0,1,"SeqNo");
ufu.mark.c:      mvwprintw(env->body,0,7,"Panel");
ufu.mark.c:      mvwprintw(env->body,0,13,"Name");
ufu.mark.c:      mvwprintw(env->body,0,68+(width-UFU_MIN_COLS)+7,"Size");
ufu.mark.c:      mvwprintw(env->body,1,1,"----- -----");
ufu.mark.c:      mvwprintw(env->body,1,61+(width-UFU_MIN_COLS)+7,"-----------");
ufu.mark.c:        mvwprintw(env->body,1,13+i,"-");
ufu.mark.c:      ufu_wrefresh(env->body);
ufu.mark.c:        if(m==cos)  wattron(env->body,A_REVERSE);
ufu.mark.c:        mvwprintw(env->body,row+1,1,"%5d",m->seqno);
ufu.mark.c:        mvwprintw(env->body,row+1,7," %3d ",m->panel);
ufu.mark.c:        mvwprintw(env->body,row+1,13,"%-s",s);
ufu.mark.c:          mvwprintw(env->body,row+1,13+i," ");
ufu.mark.c:          mvwprintw(env->body,row+1,68+(width-UFU_MIN_COLS),"           ");
ufu.mark.c:          mvwprintw(env->body,row+1,68+(width-UFU_MIN_COLS),"%11d",m->entry->size);
ufu.mark.c:        if(m==cos)  wattroff(env->body,A_REVERSE);
ufu.mark.c:    ufu_wrefresh(env->body);
ufu.mark.c:        env->key_help++;
ufu.mark.c:        ufu_help(env,env->mpanel+1,UFU_HELP_MARK);
ufu.mark.c:        env->key_info++;
ufu.mark.c:        env->key_down++;
ufu.mark.c:        env->key_up++;
ufu.mark.c:        env->key_first++;
ufu.mark.c:        tos=env->mfirst;
ufu.mark.c:        cos=env->mfirst;
ufu.mark.c:        env->key_last++;
ufu.mark.c:        //env->panel[panel]->cos=cos;
ufu.mark.c:        //env->panel[panel]->tos=cos;
ufu.mark.c:        env->key_next_page++;
ufu.mark.c:        env->key_prev_page++;
ufu.mark.c:        env->key_rem_mark++;
ufu.mark.c:            env->mfirst=cos->next;
ufu.mark.c:            env->mlast=cos->prev;
ufu.mark.c:            env->mfirst=NULL;
ufu.mark.c:            env->mlast=NULL;
ufu.mark.c:        again=(env->mfirst!=NULL);
ufu.mark.c:        env->key_edit++;
ufu.mark.c:        if(env->panel[cos->panel]->remote) {
ufu.mark.c:        env->key_view++;
ufu.mark.c:        if(env->panel[cos->panel]->remote) {
ufu.mark.c:        env->key_go++;
ufu.mark.c:        sprintf(env->msg,"%s, enter your seqno:",env->master);
ufu.mark.c:        ufu_rl(env,env->bottom,strlen(env->msg)+1,0,TRUE,5,5,inp,TRUE,FALSE);
ufu.mark.c:        env->m_cos=cos;
ufu.mark.c:        env->m_tos=tos;
ufu.mark.c:        cos=env->m_cos;
ufu.mark.c:        tos=env->m_tos;
ufu.mark.c:        env->key_config++;
ufu.mark.c:        env->key_setting++;
ufu.mark.c:        env->key_view++;
ufu.mark.c:        ufu_cmd_view(env,env->logname,NULL);
ufu.mark.c:        env->key_search++;
ufu.mark.c:        sprintf(env->msg,"%s, enter pattern:",env->master);
ufu.mark.c:        len=env->cols-strlen(env->msg)-1;
ufu.mark.c:        ufu_rl(env,env->bottom,strlen(env->msg)+1,0,TRUE,len-1,len-1,inp,TRUE,FALSE);
ufu.mark.c:        env->m_cos=cos;
ufu.mark.c:        env->m_tos=tos;
ufu.mark.c:        cos=env->m_cos;
ufu.mark.c:        tos=env->m_tos;
ufu.mark.c:        env->key_show_mark_action++;
ufu.mark.c:  sprintf(env->msg,"%s, do you wish to empty your remarkable list? ",env->master);
ufu.mark.c:    env->key_expunge++;
ufu.mark.c:    m=env->mfirst;
ufu.mark.c:    env->mfirst=NULL;
ufu.mark.c:    env->mlast=NULL;
ufu.mem.c:  env->cfgglobal=ufu_alloc_string(env,UFU_LEN_NAME);
ufu.mem.c:  env->cfglocal=ufu_alloc_string(env,UFU_LEN_NAME);
ufu.mem.c:  env->logname=ufu_alloc_string(env,UFU_LEN_NAME);
ufu.mem.c:  env->msg=ufu_alloc_string(env,UFU_LEN_MSG);
ufu.mem.c:  env->gname=ufu_alloc_string(env,UFU_LEN_GROUP);
ufu.mem.c:  env->editor=ufu_alloc_string(env,UFU_LEN_NAME);
ufu.mem.c:  env->viewer=ufu_alloc_string(env,UFU_LEN_NAME);
ufu.mem.c:  env->nodename=ufu_alloc_string(env,UFU_LEN_UTS);
ufu.mem.c:  env->sysname=ufu_alloc_string(env,UFU_LEN_UTS);
ufu.mem.c:  env->release=ufu_alloc_string(env,UFU_LEN_UTS);
ufu.mem.c:  env->master=ufu_alloc_string(env,UFU_LEN_MASTER);
ufu.mem.c:  env->rb_path=ufu_alloc_string(env,UFU_LEN_DNAME);
ufu.mem.c:  env->cpanel=UFU_MIN_PANEL;
ufu.mem.c:  env->mpanel=UFU_MAX_PANEL;
ufu.mem.c:  env->cols=0;
ufu.mem.c:  env->rows=0;
ufu.mem.c:  env->cfg_cols=0;
ufu.mem.c:  env->cfg_rows=0;
ufu.mem.c:  env->debug=debug;
ufu.mem.c:  strcpy(env->nodename,u.nodename);
ufu.mem.c:  strcpy(env->sysname,u.sysname);
ufu.mem.c:  strcpy(env->release,u.release);
ufu.mem.c:  env->pid=getpid();
ufu.mem.c:  env->ppid=getppid();
ufu.mem.c:  strcpy(env->editor,"\0");
ufu.mem.c:  strcpy(env->viewer,"\0");
ufu.mem.c:  env->homedir=getenv("HOME");
ufu.mem.c:  env->workdir=getenv("PWD");
ufu.mem.c:  env->uname=getenv("LOGNAME");
ufu.mem.c:  env->rows=ufu_get_rows(env);
ufu.mem.c:  env->cols=ufu_get_cols(env);
ufu.mem.c:  if(env->rows<UFU_MIN_ROWS) {
ufu.mem.c:    printf("Number of rows (%d) less than %d!\n",env->rows,UFU_MIN_ROWS);
ufu.mem.c:  if(env->cols<UFU_MIN_COLS) {
ufu.mem.c:    printf("Number of columns (%d) less than %d!\n",env->cols,UFU_MIN_COLS);
ufu.mem.c:  env->confirmcopy=TRUE;
ufu.mem.c:  env->confirmmove=TRUE;
ufu.mem.c:  env->confirmremove=TRUE;
ufu.mem.c:  env->ignoreerror=FALSE;
ufu.mem.c:  env->incsubdir=FALSE;
ufu.mem.c:  env->dirfirst=TRUE;
ufu.mem.c:  env->removelog=TRUE;
ufu.mem.c:  env->rb=FALSE;
ufu.mem.c:  env->rb_size=64;
ufu.mem.c:  ufu_concat_dir(env,env->rb_path,env->homedir,UFU_RBDIR);
ufu.mem.c:  env->history_min=99;
ufu.mem.c:  env->history_max=99;
ufu.mem.c:  env->max_to_mark=UFU_MAX_MARK;
ufu.mem.c:  env->hist_panel=0;
ufu.mem.c:  env->hist_mark=0;
ufu.mem.c:  env->hist_mark_action=0;
ufu.mem.c:  env->hist_ucmd=0;
ufu.mem.c:  env->hist_xinfo=0;
ufu.mem.c:  env->hist_remote=0;
ufu.mem.c:  env->hist_setup=0;
ufu.mem.c:  env->timeout=100;
ufu.mem.c:  env->timeout_retry=4;
ufu.mem.c:  env->timein=100;
ufu.mem.c:  env->timein_retry=4;
ufu.mem.c:  strcpy(env->cfgglobal,UFU_GLOBAL_CONFIG);
ufu.mem.c:  strcpy(env->cfglocal,env->homedir);
ufu.mem.c:  if(strcmp(env->cfglocal,"/")!=0) {
ufu.mem.c:    strcat(env->cfglocal,"/");
ufu.mem.c:  strcat(env->cfglocal,UFU_LOCAL_CONFIG);
ufu.mem.c:  strcpy(env->logname,env->homedir);
ufu.mem.c:  if(strcmp(env->logname,"/")!=0) {
ufu.mem.c:    strcat(env->logname,"/");
ufu.mem.c:  strcat(env->logname,UFU_LOGDIR);
ufu.mem.c:  mkdir(env->logname,0700);
ufu.mem.c:  mkdir(env->rb_path,0700);
ufu.mem.c:  strcat(env->logname,"/");
ufu.mem.c:  strcat(env->logname,UFU_LOGFILE);
ufu.mem.c:  sprintf(spid,"%d",env->pid);
ufu.mem.c:  strcat(env->logname,".");
ufu.mem.c:  strcat(env->logname,spid);
ufu.mem.c:  env->lognamefp=NULL;
ufu.mem.c:  sprintf(env->msg,"UFU started as executable '%s'.",argv[0]);
ufu.mem.c:  if(env->debug) {
ufu.mem.c:    sprintf(env->msg,"DEBUG turned on due to the commandline argument '-d'.");
ufu.mem.c:  sprintf(env->msg,"Reading HOMEDIR (%s) from environment.",env->homedir);
ufu.mem.c:  sprintf(env->msg,"Reading WORKDIR (%s) from environment.",env->workdir);
ufu.mem.c:  sprintf(env->msg,"Reading LINES (%d) from environment.",env->rows);
ufu.mem.c:  sprintf(env->msg,"Reading COLUMNS (%d) from environment.",env->cols);
ufu.mem.c:  env->ufirst=NULL;
ufu.mem.c:  env->gfirst=NULL;
ufu.mem.c:  env->mfirst=NULL;
ufu.mem.c:  env->mlast=NULL;
ufu.mem.c:  env->ucfirst=NULL;
ufu.mem.c:  env->uclast=NULL;
ufu.mem.c:  env->rhfirst=NULL;
ufu.mem.c:  env->rhlast=NULL;
ufu.mem.c:  env->sfirst=NULL;
ufu.mem.c:  sprintf(env->msg,"Finding uid/gid for user \"%s\".",env->uname);
ufu.mem.c:  env->uid=ufu_search_uid(env,env->uname);
ufu.mem.c:  env->gid=ufu_search_user_gid(env,env->uid);
ufu.mem.c:  strcpy(env->gname,ufu_search_group(env,env->gid));
ufu.mem.c:  sprintf(env->msg,"User \"%s\": uid %d, gid %d (%s).",env->uname,env->uid,env->gid,ufu_search_group(env,env->gid));
ufu.mem.c:  for(i=UFU_MIN_PANEL;i<=env->mpanel;i++) {
ufu.mem.c:    env->panel[i]=ufu_alloc_panel(env,i);
ufu.mem.c:  p=ufu_read_config(env,UFU_MIN_PANEL,env->cfgglobal,argc,argv);
ufu.mem.c:  ufu_read_config(env,p,env->cfglocal,0,NULL);
ufu.mem.c:  if((env->rows>0)&&(env->cols>0)) {
ufu.mem.c:    sprintf(env->msg,"Using ROWS/COLUMNS from environment.");
ufu.mem.c:    if((env->cfg_cols>0)&&(env->cfg_rows>0)) {
ufu.mem.c:      sprintf(env->msg,"Using ROWS/COLUMNS from config.");
ufu.mem.c:      env->cols=env->cfg_cols;
ufu.mem.c:      env->rows=env->cfg_rows;
ufu.mem.c:  if(env->cols<80)  env->cols=80;
ufu.mem.c:  if(env->rows<24)  env->rows=24;
ufu.mem.c:  strcpy(env->master,env->uname);
ufu.mem.c:  strcat(env->master," from ");
ufu.mem.c:  strcat(env->master,env->nodename);
ufu.mem.c:  env->hfirst=NULL;
ufu.mem.c:  env->key_help=0;
ufu.mem.c:  env->key_info=0;
ufu.mem.c:  env->key_up=0;
ufu.mem.c:  env->key_down=0;
ufu.mem.c:  env->key_left=0;
ufu.mem.c:  env->key_right=0;
ufu.mem.c:  env->key_next_page=0;
ufu.mem.c:  env->key_prev_page=0;
ufu.mem.c:  env->key_panel=0;
ufu.mem.c:  env->key_next_panel=0;
ufu.mem.c:  env->key_prev_panel=0;
ufu.mem.c:  env->key_setting=0;
ufu.mem.c:  env->key_dir_up=0;
ufu.mem.c:  env->key_dir_root=0;
ufu.mem.c:  env->key_dir_home=0;
ufu.mem.c:  env->key_dir_prev=0;
ufu.mem.c:  env->key_dir_work=0;
ufu.mem.c:  env->key_first=0;
ufu.mem.c:  env->key_last=0;
ufu.mem.c:  env->key_select=0;
ufu.mem.c:  env->key_edit=0;
ufu.mem.c:  env->key_view=0;
ufu.mem.c:  env->key_expunge=0;
ufu.mem.c:  env->key_show_mark=0;
ufu.mem.c:  env->key_show_mark_action=0;
ufu.mem.c:  env->key_add_mark=0;
ufu.mem.c:  env->key_rem_mark=0;
ufu.mem.c:  env->key_add_panel=0;
ufu.mem.c:  env->key_rem_panel=0;
ufu.mem.c:  env->key_add_ucmd=0;
ufu.mem.c:  env->key_rem_ucmd=0;
ufu.mem.c:  env->key_header=0;
ufu.mem.c:  env->key_sort_col=0;
ufu.mem.c:  env->key_sort_order=0;
ufu.mem.c:  env->key_go=0;
ufu.mem.c:  env->key_rb=0;
ufu.mem.c:  env->key_search=0;
ufu.mem.c:  env->key_config_1=0;
ufu.mem.c:  env->key_config_2=0;
ufu.mem.c:  env->key_config_3=0;
ufu.mem.c:  env->key_config_4=0;
ufu.mem.c:  env->key_config_5=0;
ufu.mem.c:  env->key_config_6=0;
ufu.mem.c:  env->key_config_7=0;
ufu.mem.c:  env->key_ucmd_0=0;
ufu.mem.c:  env->key_ucmd_1=0;
ufu.mem.c:  env->key_ucmd_2=0;
ufu.mem.c:  env->key_ucmd_3=0;
ufu.mem.c:  env->key_ucmd_4=0;
ufu.mem.c:  env->key_ucmd_5=0;
ufu.mem.c:  env->key_ucmd_6=0;
ufu.mem.c:  env->key_ucmd_7=0;
ufu.mem.c:  env->key_ucmd_8=0;
ufu.mem.c:  env->key_ucmd_9=0;
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_panel'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_panel));
ufu.mem.c:  if(env->debug) {
ufu.mem.c:    sprintf(env->msg,"Allocating memory for panel #%d.",panel);
ufu.mem.c:  strcpy(p->nodename,env->nodename);
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_entry'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_entry));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_split'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_split));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_usr'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_usr));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_grp'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_grp));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 'dirent'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct dirent));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 'stat'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct stat));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_mark'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_mark));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_ucmd'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_ucmd));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_remote'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_remote));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_hist'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_hist));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_xcheck'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_xcheck));
ufu.mem.c:    sprintf(env->msg,"Unable to allocate memory for datatype 'char'!");
ufu.mem.c:    sprintf(env->msg,"Needed: %d bytes.",(sizeof(char)*len)+1);
ufu.mem.c:  sprintf(env->msg,"Releasing global environment.");
ufu.mem.c:  for(i=UFU_MIN_PANEL;i<=env->mpanel;i++) {
ufu.mem.c:  uc=env->ucfirst;
ufu.mem.c:  m=env->mfirst;
ufu.mem.c:  ufu_free_string(env,env->cfglocal);
ufu.mem.c:  ufu_free_string(env,env->cfgglobal);
ufu.mem.c:  ufu_free_string(env,env->logname);
ufu.mem.c:  ufu_free_string(env,env->editor);
ufu.mem.c:  ufu_free_string(env,env->viewer);
ufu.mem.c:  ufu_free_string(env,env->gname);
ufu.mem.c:  ufu_free_string(env,env->rb_path);
ufu.mem.c:  ufu_free_string(env,env->nodename);
ufu.mem.c:  ufu_free_string(env,env->sysname);
ufu.mem.c:  ufu_free_string(env,env->release);
ufu.mem.c:  ufu_free_string(env,env->master);
ufu.mem.c:  sprintf(env->msg,"End of release.");
ufu.mem.c:  ufu_free_string(env,env->msg);
ufu.mem.c:  if(env->panel[p]!=NULL) {
ufu.mem.c:    if(env->panel[p]->first!=NULL) {
ufu.mem.c:    ufu_free_string(env,env->panel[p]->dirname);
ufu.mem.c:    ufu_free_string(env,env->panel[p]->dirnameprev);
ufu.mem.c:    ufu_free_string(env,env->panel[p]->nodename);
ufu.mem.c:    free(env->panel[p]);
ufu.mem.c:  sprintf(env->msg," Releasing panel #%d (%s).",p,env->panel[p]->dirname);
ufu.mem.c:  e=env->panel[p]->first;
ufu.mem.c:  if(env->debug) {
ufu.mem.c:    sprintf(env->msg," Releasing entry \"%s\".",e->fname);
ufu.mem.c:  if(env->debug) {
ufu.mem.c:    sprintf(env->msg," Releasing split \"%s\".",s->name);
ufu.misc.c:  strcpy(env->msg,asctime(localtime(&result)));
ufu.misc.c:  env->msg[strlen(env->msg)-1]='\0';
ufu.misc.c:  strcpy(env->msg,ctime(timestamp));
ufu.misc.c:  env->msg[strlen(env->msg)-1]='\0';
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:  mvwprintw(env->bottom,0,0,"%s, will you give me your any key? ",env->master);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  wgetch(env->bottom);
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:  mvwprintw(env->bottom,0,0,"%s, this isn't and will never be a valid choice! ",env->master);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  wgetch(env->bottom);
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:        mvwprintw(env->bottom,0,0,"%s ",s);
ufu.misc.c:        mvwprintw(env->bottom,0,0,"%s, your wish is my command: ",env->master);
ufu.misc.c:      mvwprintw(env->bottom,0,0,"%s, your (marked) wish is my command: ",env->master);
ufu.misc.c:      mvwprintw(env->bottom,0,0,"%s, your (executed) wish is my command: ",env->master);
ufu.misc.c:      mvwprintw(env->bottom,0,0,"%s, your (remote) wish is my command: ",env->master);
ufu.misc.c:      mvwprintw(env->bottom,0,0,"%s, too many (>%d) marked files: ",env->master,env->max_to_mark);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  return(tolower(wgetch(env->bottom)));
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:  mvwprintw(env->bottom,0,0,"%s",env->msg);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  return(tolower(wgetch(env->bottom)));
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:  mvwprintw(env->bottom,0,0,"%s",env->msg);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  return(tolower(wgetch(env->bottom))=='y');
ufu.misc.c:  if(strlen(env->msg)>0) {
ufu.misc.c:    ufu_wclear(env->bottom);
ufu.misc.c:    mvwprintw(env->bottom,0,0,env->msg);
ufu.misc.c:    ufu_wrefresh(env->bottom);
ufu.misc.c:  sprintf(env->msg,"%s Any key? ",env->msg);
ufu.misc.c:  ufu_wclear(env->bottom);
ufu.misc.c:  mvwprintw(env->bottom,0,0,env->msg);
ufu.misc.c:  ufu_wrefresh(env->bottom);
ufu.misc.c:  wgetch(env->bottom);
ufu.misc.c:  if(env->cols<=80) {
ufu.misc.c:    if(env->cols<=(80+25)) {
ufu.misc.c:      if(env->cols<=(80+25+25)) {
ufu.misc.c:        if(env->cols<=(80+25+25+25)) {
ufu.misc.c:  sprintf(env->msg,"Command to execute: %s.",line);
ufu.misc.c:  sprintf(env->msg,"Command \"%s\" returned status %d.",line,status);
ufu.misc.c:      e=env->panel[panel]->first;
ufu.misc.c:        sprintf(env->msg,"Found ENTRY for seqno %d (%s)",seqno,e->fname);
ufu.misc.c:        r=env->rows/2;
ufu.misc.c:          //sprintf(env->msg,"Found TOS with seqno %d (%s)",e->seqno,e->fname);
ufu.misc.c:          //sprintf(env->msg,"No TOS found. Seqno=%d (%s)",e_cos->seqno,e_cos->fname);
ufu.misc.c:        env->panel[panel]->cos=e_cos;
ufu.misc.c:        env->panel[panel]->tos=e_tos;
ufu.misc.c:      m=env->mfirst;
ufu.misc.c:      //env->m_cos=NULL;
ufu.misc.c:      //env->m_tos=NULL;
ufu.misc.c:        r=env->rows/2;
ufu.misc.c:        env->m_cos=m_cos;
ufu.misc.c:        env->m_tos=m_tos;
ufu.misc.c:      e=env->panel[panel]->cos;
ufu.misc.c:        sprintf(env->msg,"Found ENTRY for pattern %s (%s)",s,e->fname);
ufu.misc.c:        r=env->rows/2;
ufu.misc.c:          //sprintf(env->msg,"Found TOS with seqno %d (%s)",e->seqno,e->fname);
ufu.misc.c:          //sprintf(env->msg,"No TOS found. Seqno=%d (%s)",e_cos->seqno,e_cos->fname);
ufu.misc.c:        env->panel[panel]->cos=e_cos;
ufu.misc.c:        env->panel[panel]->tos=e_tos;
ufu.misc.c:        sprintf(env->msg,"No entry for pattern %s",s);
ufu.misc.c:      m=env->m_cos;
ufu.misc.c:        r=env->rows/2;
ufu.misc.c:        env->m_cos=m_cos;
ufu.misc.c:        env->m_tos=m_tos;
ufu.misc.c:  sprintf(env->msg,"Finding entry \"%s\":",fname);
ufu.misc.c:    p=env->panel[c];
ufu.misc.c:        sprintf(env->msg," Panel #%d (%s): found %d",c,p->dirname,founde);
ufu.misc.c:  sprintf(env->msg," All panels: found %d",found);
ufu.panel.c:  sprintf(env->msg,"Start reading panels.");
ufu.panel.c:  for(p=UFU_MIN_PANEL;p<=env->mpanel;p++) {
ufu.panel.c:  sprintf(env->msg,"End of reading panels.");
ufu.panel.c:  height=env->rows-6;
ufu.panel.c:  width=env->cols;
ufu.panel.c:  while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.panel.c:      ufu_wclear(env->top);
ufu.panel.c:      mvwprintw(env->top,0,0,"[%s] Choose panel. Total %d panels, %d used, %d unused",env->nodename,env->mpanel-UFU_MIN_PANEL+1,max_p-UFU_MIN_PANEL+1,env->mpanel-UFU_MIN_PANEL-max_p);
ufu.panel.c:      ufu_wrefresh(env->top);
ufu.panel.c:      ufu_wclear(env->bottom);
ufu.panel.c:      ufu_wrefresh(env->bottom);
ufu.panel.c:      ufu_wclear(env->body);
ufu.panel.c:      mvwprintw(env->body,0,1,"No");
ufu.panel.c:      mvwprintw(env->body,0,4,"?");
ufu.panel.c:      mvwprintw(env->body,0,6,"Node");
ufu.panel.c:      mvwprintw(env->body,0,19,"Directory");
ufu.panel.c:      mvwprintw(env->body,1,1,"--");
ufu.panel.c:      mvwprintw(env->body,1,4,"-");
ufu.panel.c:      mvwprintw(env->body,1,6,"------------");
ufu.panel.c:      mvwprintw(env->body,0,65+(width-UFU_MIN_COLS),"Files");
ufu.panel.c:      mvwprintw(env->body,0,71+(width-UFU_MIN_COLS),"Dirs");
ufu.panel.c:      mvwprintw(env->body,0,76+(width-UFU_MIN_COLS),"HCO");
ufu.panel.c:        mvwprintw(env->body,1,19+i,"-");
ufu.panel.c:      mvwprintw(env->body,1,65+(width-UFU_MIN_COLS),"-----");
ufu.panel.c:      mvwprintw(env->body,1,71+(width-UFU_MIN_COLS),"----");
ufu.panel.c:      mvwprintw(env->body,1,76+(width-UFU_MIN_COLS),"---");
ufu.panel.c:      ufu_wrefresh(env->body);
ufu.panel.c:        if(p==panel)  wattron(env->body,A_REVERSE);
ufu.panel.c:        mvwprintw(env->body,p-tos+2,1,"%2d",p);
ufu.panel.c:        if(env->panel[p]->local)
ufu.panel.c:          mvwprintw(env->body,p-tos+2,4,"L");
ufu.panel.c:          mvwprintw(env->body,p-tos+2,4,"G");
ufu.panel.c:        if(strlen(env->panel[p]->dirname)>0) {
ufu.panel.c:          if(env->panel[p]->remote)
ufu.panel.c:            mvwprintw(env->body,p-tos+2,6,"%-12s",env->panel[p]->nodename);
ufu.panel.c:            mvwprintw(env->body,p-tos+2,6,"[local node]");
ufu.panel.c:          ufu_resize_string(env,env->panel[p]->dirname,45+(width-UFU_MIN_COLS),s);
ufu.panel.c:          mvwprintw(env->body,p-tos+2,19,"%s",s);
ufu.panel.c:            mvwprintw(env->body,p-tos+2,19+i," ");
ufu.panel.c:          mvwprintw(env->body,p-tos+2,65+(width-UFU_MIN_COLS),"%5d",env->panel[p]->nfiles);
ufu.panel.c:          mvwprintw(env->body,p-tos+2,71+(width-UFU_MIN_COLS),"%4d",env->panel[p]->ndirs);
ufu.panel.c:          switch(env->panel[p]->header) {
ufu.panel.c:              mvwprintw(env->body,p-tos+2,76+(width-UFU_MIN_COLS),"S");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,76+(width-UFU_MIN_COLS),"A");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,76+(width-UFU_MIN_COLS),"M");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,76+(width-UFU_MIN_COLS),"C");
ufu.panel.c:          switch(env->panel[p]->sortc) {
ufu.panel.c:              mvwprintw(env->body,p-tos+2,77+(width-UFU_MIN_COLS),"F");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,77+(width-UFU_MIN_COLS),"S");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,77+(width-UFU_MIN_COLS),"A");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,77+(width-UFU_MIN_COLS),"M");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,77+(width-UFU_MIN_COLS),"C");
ufu.panel.c:          switch(env->panel[p]->sorto) {
ufu.panel.c:              mvwprintw(env->body,p-tos+2,78+(width-UFU_MIN_COLS),"A");
ufu.panel.c:              mvwprintw(env->body,p-tos+2,78+(width-UFU_MIN_COLS),"D");
ufu.panel.c:          mvwprintw(env->body,p+2,3,"[ NA ]");
ufu.panel.c:        if(p==panel)  wattroff(env->body,A_REVERSE);
ufu.panel.c:    ufu_wrefresh(env->body);
ufu.panel.c:        env->key_help++;
ufu.panel.c:        env->key_view++;
ufu.panel.c:        ufu_cmd_view(env,env->logname,NULL);
ufu.panel.c:        env->key_select++;
ufu.panel.c:        env->key_up++;
ufu.panel.c:        env->key_down++;
ufu.panel.c:        env->key_prev_page++;
ufu.panel.c:        env->key_next_page++;
ufu.panel.c:        env->key_first++;
ufu.panel.c:        env->key_last++;
ufu.panel.c:        env->key_add_panel++;
ufu.panel.c:        if(!(env->panel[panel]->remote)) {
ufu.panel.c:          if(max_p<env->mpanel) {
ufu.panel.c:            strcpy(env->panel[max_p+1]->dirname,env->panel[panel]->dirname);
ufu.panel.c:            env->panel[max_p+1]->header=env->panel[panel]->header;
ufu.panel.c:            while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.panel.c:          sprintf(env->msg,"Can't copy a remote panel!");
ufu.panel.c:        env->key_rem_panel++;
ufu.panel.c:          m=env->mfirst;
ufu.panel.c:            sprintf(env->msg,"Can't delete panel #%d! Marked entries for this panel: %d.",panel,in_use);
ufu.panel.c:            if(env->confirmremove) {
ufu.panel.c:              sprintf(env->msg,"Delete panel #%d (%s). Are you sure? ",panel,env->panel[panel]->dirname);
ufu.panel.c:            if((!env->confirmremove)||(ufu_get_y(env))) {
ufu.panel.c:                env->panel[p]=env->panel[p+1];
ufu.panel.c:              env->panel[max_p]=ufu_alloc_panel(env,max_p);
ufu.panel.c:              while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.panel.c:          sprintf(env->msg,"Can't remove a fixed panel!");
ufu.panel.c:        env->key_info++;
ufu.panel.c:        if(env->panel[panel]->remote) {
ufu.panel.c:          ufu_com_read_entry(env,env->panel[panel]->dirname,panel,e);
ufu.panel.c:          ufu_info_entry(env,e,panel,NULL,env->panel[panel],UFU_INFO_PANEL);
ufu.panel.c:          ufu_stat_entry(env,env->mpanel+1,env->panel[panel]->info);
ufu.panel.c:          ufu_info_entry(env,env->panel[panel]->info,panel,NULL,env->panel[panel],UFU_INFO_PANEL);
ufu.panel.c:        env->key_show_mark++;
ufu.panel.c:        env->key_add_mark++;
ufu.panel.c:        while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.panel.c:    sprintf(env->msg,"Adjusting current panel to %d (%s).",panel,env->panel[panel]->dirname);
ufu.panel.c:  height=env->rows-6;
ufu.panel.c:  while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.panel.c:  w=ufu_popup(env,65,15,(env->cols-70)/2,(env->rows-14)/2,"Select panel");
ufu.panel.c:        if(env->panel[p]->local)
ufu.panel.c:        if(strlen(env->panel[p]->dirname)>0) {
ufu.panel.c:          if(env->panel[p]->remote)
ufu.panel.c:            mvwprintw(w,p-tos+3,6,"%-12s",env->panel[p]->nodename);
ufu.panel.c:          ufu_resize_string(env,env->panel[p]->dirname,45,s);
ufu.panel.c:        env->key_select++;
ufu.panel.c:        env->key_up++;
ufu.panel.c:        env->key_down++;
ufu.panel.c:        env->key_prev_page++;
ufu.panel.c:        env->key_next_page++;
ufu.panel.c:        env->key_first++;
ufu.panel.c:        env->key_last++;
ufu.panel.c:        env->key_help++;
ufu.panel.c:  ufu_wrefresh(env->body);
ufu.remote.c:  if(env->debug) {
ufu.remote.c:    sprintf(env->msg,"Remote: Line to split \"%s\".",s);
ufu.remote.c:  if(env->debug) {
ufu.remote.c:      sprintf(env->msg,"Remote: Split ok!");
ufu.remote.c:      sprintf(env->msg,"        Hostname=%s:%d",rh->hostname,rh->port);
ufu.remote.c:      sprintf(env->msg,"        Username=%s",rh->username);
ufu.remote.c:      sprintf(env->msg,"        Directory=%s",rh->dirname);
ufu.remote.c:      sprintf(env->msg,"Remote: Spliterror (%s).",s);
ufu.remote.c:    sprintf(env->msg,"Edit remote host %d (host=%s,port=%d,user=%s).",rh->seqno,rh->hostname,rh->port,rh->username);
ufu.remote.c:    sprintf(env->msg,"Edit empty host.");
ufu.remote.c:    ufu_wclear(env->top);
ufu.remote.c:    mvwprintw(env->top,0,0,"[%s] Edit remote host properties",env->nodename);
ufu.remote.c:    ufu_wrefresh(env->top);
ufu.remote.c:    ufu_wclear(env->body);
ufu.remote.c:    ufu_wrefresh(env->body);
ufu.remote.c:    mvwprintw(env->body,row,col,"Hostname : %s",rh->hostname);
ufu.remote.c:    mvwprintw(env->body,row+1,col,"Username : %s",rh->username);
ufu.remote.c:    mvwprintw(env->body,row+2,col,"Port     : %d",rh->port);
ufu.remote.c:    mvwprintw(env->body,row+3,col,"Directory: %s",rh->dirname);
ufu.remote.c:    ufu_wrefresh(env->body);
ufu.remote.c:        ufu_rl(env,env->body,col+11,row,insert,UFU_REM_HOSTNAME,UFU_REM_HOSTNAME,rh->hostname,TRUE,TRUE);
ufu.remote.c:        ufu_rl(env,env->body,col+11,row+1,insert,UFU_REM_USERNAME,12,rh->username,TRUE,TRUE);
ufu.remote.c:        ufu_rl(env,env->body,col+11,row+2,insert,UFU_REM_PORT,UFU_REM_PORT,s,TRUE,TRUE);
ufu.remote.c:        ufu_rl(env,env->body,col+11,row+3,insert,UFU_REM_DIRNAME,UFU_REM_DIRNAME,rh->dirname,TRUE,TRUE);
ufu.remote.c:    ufu_wrefresh(env->body);
ufu.remote.c:  if(env->rhlast!=NULL) {
ufu.remote.c:    rhlast=env->rhlast;
ufu.remote.c:    env->rhlast=rh_tmp;
ufu.remote.c:    env->rhfirst=rh_tmp;
ufu.remote.c:    env->rhlast=rh_tmp;
ufu.remote.c:  //sprintf(env->msg,"Add remote host (%s,%d,%s).",rh_tmp->hostname,rh_tmp->port,rh_tmp->username);
ufu.remote.c:  sprintf(env->msg,"Delete remote host %d (host=%s,port=%d,user=%s).",rh->seqno,rh->hostname,rh->port,rh->username);
ufu.remote.c:      env->rhfirst=NULL;
ufu.remote.c:      env->rhlast=NULL;
ufu.remote.c:      env->rhfirst=rh->next;
ufu.remote.c:      env->rhlast=rh->prev;
ufu.remote.c:  rh=env->rhfirst;
ufu.remote.c:  r=env->rhfirst;
ufu.remote.c:    r1=env->rhfirst;
ufu.remote.c:  width=env->cols;
ufu.remote.c:  rows=env->rows-6;
ufu.remote.c:  rh=env->rhfirst;
ufu.remote.c:    tos=env->rhfirst;
ufu.remote.c:    cos=env->rhfirst;
ufu.remote.c:    rh=env->rhfirst;
ufu.remote.c:      ufu_wclear(env->top);
ufu.remote.c:        mvwprintw(env->top,0,0,"[%s] REMOTE - Missing connection: %s",env->nodename,missing);
ufu.remote.c:        mvwprintw(env->top,0,0,"[%s] Show remote hosts",env->nodename);
ufu.remote.c:      ufu_wrefresh(env->top);
ufu.remote.c:      ufu_wclear(env->bottom);
ufu.remote.c:      ufu_wrefresh(env->bottom);
ufu.remote.c:      ufu_wclear(env->body);
ufu.remote.c:      mvwprintw(env->body,0,1,"SeqNo");
ufu.remote.c:      mvwprintw(env->body,0,7,"Hostname");
ufu.remote.c:      mvwprintw(env->body,0,25,"Port");
ufu.remote.c:      mvwprintw(env->body,0,30,"Username");
ufu.remote.c:      mvwprintw(env->body,0,43,"Directory");
ufu.remote.c:      mvwprintw(env->body,0,76+(width-UFU_MIN_COLS),"pwd");
ufu.remote.c:      mvwprintw(env->body,1,1,"-----");
ufu.remote.c:      mvwprintw(env->body,1,7,"----------------");
ufu.remote.c:      mvwprintw(env->body,1,24,"-----");
ufu.remote.c:      mvwprintw(env->body,1,30,"------------");
ufu.remote.c:      mvwprintw(env->body,1,76+(width-UFU_MIN_COLS),"---");
ufu.remote.c:        mvwprintw(env->body,1,43+i,"-");
ufu.remote.c:      ufu_wrefresh(env->body);
ufu.remote.c:        if(rh==cos)  wattron(env->body,A_REVERSE);
ufu.remote.c:        mvwprintw(env->body,row+1,1,"%5d",rh->seqno);
ufu.remote.c:        mvwprintw(env->body,row+1,7,"%-16s",s);
ufu.remote.c:        mvwprintw(env->body,row+1,24,"%5d",rh->port);
ufu.remote.c:        mvwprintw(env->body,row+1,30,"%-12s",s);
ufu.remote.c:        mvwprintw(env->body,row+1,43,"%s",s);
ufu.remote.c:          mvwprintw(env->body,row+1,43+i," ");
ufu.remote.c:        if(rh==cos)  wattroff(env->body,A_REVERSE);
ufu.remote.c:          mvwprintw(env->body,row+1,76+(width-UFU_MIN_COLS)," Y ");
ufu.remote.c:          mvwprintw(env->body,row+1,76+(width-UFU_MIN_COLS),"   ");
ufu.remote.c:    ufu_wrefresh(env->body);
ufu.remote.c:        ufu_help(env,env->mpanel+1,UFU_HELP_REMOTE);
ufu.remote.c:        tos=env->rhfirst;
ufu.remote.c:        cos=env->rhfirst;
ufu.remote.c:        if(env->confirmremove) {
ufu.remote.c:          sprintf(env->msg,"%s, are you sure to remove this (%d) entry? ",env->master,cos->seqno);
ufu.remote.c:        if((!env->confirmremove)||(ufu_get_yn(env))) {
ufu.remote.c:            if(seq_bos>env->rhlast->seqno) {
ufu.remote.c:              seq_bos=env->rhlast->seqno;
ufu.remote.c:              cos=env->rhfirst;
ufu.remote.c:        cos=env->rhlast;
ufu.remote.c:            mvwprintw(env->body,row+1,1,"%5d",rh->seqno);
ufu.remote.c:            if(rh==cos)  wattron(env->body,A_REVERSE);
ufu.remote.c:            mvwprintw(env->body,row+1,7,"%-32s",rh->hostname);
ufu.remote.c:            mvwprintw(env->body,row+1,40,"%5d",rh->port);
ufu.remote.c:            mvwprintw(env->body,row+1,46,"%-16s",rh->username);
ufu.remote.c:            if(rh==cos)  wattroff(env->body,A_REVERSE);
ufu.remote.c:              mvwprintw(env->body,row+1,63,"Y");
ufu.remote.c:              mvwprintw(env->body,row+1,63,"N");
ufu.remote.c:        ufu_wrefresh(env->body);
ufu.remote.c:        sprintf(env->msg,"Enter password for user %s: ",cos->username);
ufu.remote.c:        ufu_rl(env,env->bottom,strlen(env->msg),0,TRUE,UFU_LEN_PWORD+1,UFU_LEN_PWORD+1,cos->password,FALSE,FALSE);
ufu.remote.c:          sprintf(env->msg,"Enter password for user %s: ",cos->username);
ufu.remote.c:          ufu_rl(env,env->bottom,strlen(env->msg),0,TRUE,UFU_LEN_PWORD+1,UFU_LEN_PWORD+1,cos->password,FALSE,FALSE);
ufu.remote.c:        sprintf(env->msg,"%s, please wait... ",env->master);
ufu.remote.c:          while((p<=env->mpanel)&&(strlen(env->panel[p]->dirname)>0)) {
ufu.remote.c:          if(p<env->mpanel) {
ufu.remote.c:            sprintf(env->msg,"Free panel found: %d",p);
ufu.remote.c:            env->panel[p]->rem=cos;
ufu.remote.c:            sprintf(env->msg,"No free panels left!");
ufu.rl.c:  wattron(env->body,A_REVERSE);
ufu.rl.c:        sprintf(env->msg,"%s, your (editable) wish is my command: ",env->master);
ufu.rl.c:        sprintf(env->msg,"%s, your (insertable) wish is my command: ",env->master);
ufu.rl.c:      env->msg[0]='\0';
ufu.rl.c:        ufu_help(env,env->mpanel+1,UFU_HELP_RL);
ufu.rl.c:  wattroff(env->body,A_REVERSE);
ufu.rl.c:  if(env->debug) {
ufu.rl.c:    sprintf(env->msg,"String insert: Char \"%c\" on spot %d.",c,spot);
ufu.rl.c:    sprintf(env->msg,"               String \"%s\".",s);
ufu.rl.c:  if(env->debug) {
ufu.rl.c:      sprintf(env->msg,"String insert: Ok! String \"%s\".",s);
ufu.rl.c:      sprintf(env->msg,"String insert: Error!");
ufu.rl.c:  if(env->debug) {
ufu.rl.c:    sprintf(env->msg,"String delete: Char \"%c\" on spot %d.",c,spot);
ufu.rl.c:    sprintf(env->msg,"               String \"%s\".",s);
ufu.rl.c:  if(env->debug) {
ufu.rl.c:    sprintf(env->msg,"String delete: Ok! String \"%s\".",s);
ufu.sort.c:  if(strlen(env->panel[panel]->dirname)>0) {
ufu.sort.c:    switch(env->panel[panel]->sortc) {
ufu.sort.c:    switch(env->panel[panel]->sorto) {
ufu.sort.c:    sprintf(env->msg," Sorting panel #%d (%s,%c%c).",panel,env->panel[panel]->dirname,sortc,sorto);
ufu.sort.c:    if(env->dirfirst) {
ufu.sort.c:    sprintf(env->msg," Finished sorting panel #%d.",panel);
ufu.sort.c:    switch(env->panel[panel]->sortc) {
ufu.sort.c:        switch(env->panel[panel]->sorto) {
ufu.sort.c:        switch(env->panel[panel]->sorto) {
ufu.sort.c:        switch(env->panel[panel]->sorto) {
ufu.sort.c:        switch(env->panel[panel]->sorto) {
ufu.sort.c:        switch(env->panel[panel]->sorto) {
ufu.sort.c:  sprintf(env->msg," Start reshuffling of %s",env->panel[panel]->dirname);
ufu.sort.c:  sprintf(env->msg,"Reshuffling directory \"%s\"... ",env->panel[panel]->dirname);
ufu.sort.c:  e=env->panel[panel]->first;
ufu.sort.c:    sprintf(env->msg,"  Moved (first) entry \"%s\" from position %d.",e->fname,e->seqno);
ufu.sort.c:    e->next=env->panel[panel]->first;
ufu.sort.c:    env->panel[panel]->first->prev=e;
ufu.sort.c:    env->panel[panel]->first=e;
ufu.sort.c:  e=env->panel[panel]->first;
ufu.sort.c:    sprintf(env->msg,"  Moved (second) entry \"%s\" from position %d.",e->fname,e->seqno);
ufu.sort.c:    t3=env->panel[panel]->first;
ufu.sort.c:    t4=env->panel[panel]->first->next;
ufu.sort.c:  t1=env->panel[panel]->first;
ufu.sort.c:        sprintf(env->msg,"  Moving entry \"%s\".",t2->fname);
ufu.sort.c:          env->panel[panel]->first=t2->next;
ufu.sort.c:          env->panel[panel]->last=t2->prev;
ufu.sort.c:          env->panel[panel]->first=t2;
ufu.sort.c:    sprintf(env->msg,"  Start renumbering after reshuffle.");
ufu.sort.c:    e=env->panel[panel]->first;
ufu.sort.c:      env->panel[panel]->last=e;
ufu.sort.c:    sprintf(env->msg,"  Finished renumbering after reshuffle.");
ufu.sort.c:  sprintf(env->msg," Finished reshuffling of %s",env->panel[panel]->dirname);
ufu.sort.c:  sprintf(env->msg,"Sorting directory \"%s\"... ",env->panel[panel]->dirname);
ufu.sort.c:  list=env->panel[panel]->first;
ufu.sort.c:        env->panel[panel]->first=list;
ufu.sort.c:          env->panel[panel]->last=e;
ufu.sort.c:    sprintf(env->msg,"  Start renumbering after sort.");
ufu.sort.c:    e=env->panel[panel]->first;
ufu.sort.c:      env->panel[panel]->last=e;
ufu.sort.c:    sprintf(env->msg,"  Finished renumbering after sort.");
ufu.sort.c:  sprintf(env->msg," Finished sorting of %s",env->panel[panel]->dirname);
ufu.ucmd.c:  if(env->debug) {
ufu.ucmd.c:    sprintf(env->msg,"UserCMD: Edit usercommand %d (%s).",uc->seqno,uc->exec);
ufu.ucmd.c:  ok=ufu_rl(env,env->body,col,row,insert,UFU_LEN_UCMD,UFU_LEN_UCMD_VIS,uc->exec,TRUE,TRUE);
ufu.ucmd.c:  if(env->uclast!=NULL) {
ufu.ucmd.c:    uclast=env->uclast;
ufu.ucmd.c:    env->uclast=uc_tmp;
ufu.ucmd.c:    env->ucfirst=uc_tmp;
ufu.ucmd.c:    env->uclast=uc_tmp;
ufu.ucmd.c:  if(env->debug) {
ufu.ucmd.c:    sprintf(env->msg,"UserCMD: Add new usercommand %d (%s).",uc_tmp->seqno,uc_tmp->exec);
ufu.ucmd.c:  if(env->debug) {
ufu.ucmd.c:    sprintf(env->msg,"UserCMD: Delete usercommand %d (%s).",uc->seqno,uc->exec);
ufu.ucmd.c:      env->ucfirst=NULL;
ufu.ucmd.c:      env->uclast=NULL;
ufu.ucmd.c:      env->ucfirst=uc->next;
ufu.ucmd.c:      env->uclast=uc->prev;
ufu.ucmd.c:  uc=env->ucfirst;
ufu.ucmd.c:  ufu_concat_dir(env,fn,env->panel[panel]->dirname,file);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {A} replacement, command is: %s",exec);
ufu.ucmd.c:      sprintf(env->msg," UserCMD {A} replacement: %s",exec_tmp);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {A} replacement, command is: %s",exec);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {R} replacement, command is: %s",exec);
ufu.ucmd.c:      sprintf(env->msg," UserCMD {R} replacement: %s",exec_tmp);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {R} replacement, command is: %s",exec);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {B} replacement, command is: %s",exec);
ufu.ucmd.c:        strcat(exec_tmp,env->panel[panel]->dirname);
ufu.ucmd.c:        strcat(exec_tmp,env->panel[panel]->dirname);
ufu.ucmd.c:      sprintf(env->msg," UserCMD {B} replacement: %s",exec_tmp);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD {B} replacement, command is: %s",exec);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD, %d replacements!",replaced);
ufu.ucmd.c:    sprintf(env->msg,"UserCMD, no replacements.");
ufu.ucmd.c:  sprintf(env->msg,"Executing usercommand from panel %d: %s.",panel,exec);
ufu.ucmd.c:  if(env->debug) {
ufu.ucmd.c:    sprintf(env->msg,"UserCMD: Execute usercommand %d.",key);
ufu.ucmd.c:  uc=env->ucfirst;
ufu.ucmd.c:  tos=env->ucfirst;
ufu.ucmd.c:  cos=env->ucfirst;
ufu.ucmd.c:  uc=env->ucfirst;
ufu.ucmd.c:  rows=env->rows-6;
ufu.ucmd.c:  seqno=env->hist_ucmd;
ufu.ucmd.c:  uc=env->ucfirst;
ufu.ucmd.c:    uc=env->ucfirst;
ufu.ucmd.c:      ufu_wclear(env->top);
ufu.ucmd.c:      mvwprintw(env->top,0,0,"[%s] Show usercommands",env->nodename);
ufu.ucmd.c:      ufu_wrefresh(env->top);
ufu.ucmd.c:      ufu_wclear(env->bottom);
ufu.ucmd.c:      ufu_wrefresh(env->bottom);
ufu.ucmd.c:      ufu_wclear(env->body);
ufu.ucmd.c:      mvwprintw(env->body,0,1,"SeqNo Command");
ufu.ucmd.c:      mvwprintw(env->body,1,1,"----- ------------------------------------------------------------------------");
ufu.ucmd.c:      ufu_wrefresh(env->body);
ufu.ucmd.c:        if(uc==cos)  wattron(env->body,A_REVERSE);
ufu.ucmd.c:        mvwprintw(env->body,row+1,1,"%5d",uc->seqno);
ufu.ucmd.c:            mvwprintw(env->body,row+1,7+i,"%c",uc->exec[i+start]);
ufu.ucmd.c:            mvwprintw(env->body,row+1,7+i," ");
ufu.ucmd.c:        if(uc==cos)  wattroff(env->body,A_REVERSE);
ufu.ucmd.c:    ufu_wrefresh(env->body);
ufu.ucmd.c:        env->key_select++;
ufu.ucmd.c:        env->key_help++;
ufu.ucmd.c:        ufu_help(env,env->mpanel+1,UFU_HELP_UCMD);
ufu.ucmd.c:        env->key_left++;
ufu.ucmd.c:        env->key_right++;
ufu.ucmd.c:        env->key_down++;
ufu.ucmd.c:        env->key_up++;
ufu.ucmd.c:        env->key_first++;
ufu.ucmd.c:        tos=env->ucfirst;
ufu.ucmd.c:        cos=env->ucfirst;
ufu.ucmd.c:        env->key_last++;
ufu.ucmd.c:        env->key_next_page++;
ufu.ucmd.c:        env->key_prev_page++;
ufu.ucmd.c:        env->key_rem_ucmd++;
ufu.ucmd.c:          rem=!env->confirmremove;
ufu.ucmd.c:          if(env->confirmremove) {
ufu.ucmd.c:            sprintf(env->msg,"%s, are you sure to remove this humble (%d) entry? ",env->master,cos->seqno);
ufu.ucmd.c:              if(seq_bos>env->uclast->seqno) {
ufu.ucmd.c:                seq_bos=env->uclast->seqno;
ufu.ucmd.c:                cos=env->ucfirst;
ufu.ucmd.c:        env->key_add_ucmd++;
ufu.ucmd.c:        cos=env->uclast;
ufu.ucmd.c:            mvwprintw(env->body,row+1,1,"%5d",uc->seqno);
ufu.ucmd.c:            if(uc==cos)  wattron(env->body,A_REVERSE);
ufu.ucmd.c:                mvwprintw(env->body,row+1,7+i,"%c",uc->exec[i+start]);
ufu.ucmd.c:                mvwprintw(env->body,row+1,7+i," ");
ufu.ucmd.c:            if(uc==cos)  wattroff(env->body,A_REVERSE);
ufu.ucmd.c:        ufu_wrefresh(env->body);
ufu.ucmd.c:        env->key_edit++;
ufu_com_copy_entry.c:  if(ufu_com_init(env,env->panel[m->panel]->rem)) {
ufu_com_copy_entry.c:    ufu_crypt_passwd(env,b,env->panel[m->panel]->rem);
ufu_com_copy_entry.c:      strcpy(b->dirname,env->panel[m->panel]->dirname);
ufu_com_copy_entry.c:      strcpy(b->dirname,env->panel[m->panel]->dirname);
ufu_com_copy_entry.c:    sprintf(env->msg,"Remote file to unlink: %s",f);
ufu_com_copy_entry.c:    ok=ufu_send(env,env->panel[m->panel]->rem,b);
ufu_com_copy_entry.c:      if(ufu_recv(env,env->panel[m->panel]->rem,b)) {
ufu_com_copy_entry.c:          sprintf(env->msg,"Unlink succesfull!");
ufu_com_copy_entry.c:          strcpy(env->msg,b->errmsg);
ufu_com_copy_entry.c:        sprintf(env->msg,"Something wrong with transfer!");
ufu_com_copy_entry.c:      ufu_com_exit(env,env->panel[m->panel]->rem);
ufu_com_copy_entry.c:      ufu_com_exit(env,env->panel[m->panel]->rem);
ufu_com_copy_entry.c:      sprintf(env->msg,"Send failed!");
ufu_com_copy_entry.c:    sprintf(env->msg,"Unable to setup connection!");
ufu_com_copy_entry.c:    sprintf(env->msg,"Host %s is not reponding!",env->panel[m->panel]->rem->hostname);
ufud.c:  sprintf(env->msg,"%s",UFUD_BUILDDATE);
ufud.c:    sprintf(env->msg,"Unable to open socket!");
ufud.c:  sprintf(env->msg,"Socket opened.");
ufud.c:    sprintf(env->msg,"Unable to set socket options!");
ufud.c:  sprintf(env->msg,"Socket options set.");
ufud.c:  my_addr.sin_port=htons(env->port);   // short, network byte order
ufud.c:    sprintf(env->msg,"Unable to bind to port %d!",env->port);
ufud.c:  sprintf(env->msg,"Binded to port %d.",env->port);
ufud.c:  if (listen(sockfd,env->backlog)==(-1)) {
ufud.c:    sprintf(env->msg,"Unable to listen to socket!");
ufud.c:  sprintf(env->msg,"Backlog size is %d requests.",env->backlog);
ufud.c:  sprintf(env->msg,"Listening to socket.");
ufud.c:    sprintf(env->msg,"Unable to set signal functions!");
ufud.c:  sprintf(env->msg,"Signal functions set.");
ufud.c:  sprintf(env->msg,UFUD_VERSION);
ufud.c:  sprintf(env->msg,UFUD_BUILDDATE);
ufud.c:  sprintf(env->msg,"Server up and running.");
ufud.c:      sprintf(env->msg,"Unable to accept connection!");
ufud.c:      sprintf(env->msg,"Resuming application.");
ufud.c:      sprintf(env->msg,"[accept] Creating structure for client.");
ufud.c:      sprintf(env->msg,"[accept] Converting structure to numbers-and-dots notation.");
ufud.c:      sprintf(env->msg,"[accept] Converting structure to hostname.");
ufud.c:          sprintf(env->msg,"[accept]   Alias: %s",*(hp->h_aliases)++);
ufud.c:      sprintf(env->msg,"[accept] Connection from %s (%s).",ipno,ipname);
ufud.c:        env->ppid=ppid;
ufud.c:        env->pid=pid;
ufud.c:        sprintf(env->msg,"[%s] Forking new pid %d from parent %d.",ipno,pid,ppid);
ufud.c:        if((!env->auth_ip)||(ufud_auth_ip(env,ipno))) {
ufud.c:          sprintf(env->msg,"[%s] %s allowed!",ipno,ipname);
ufud.c:              ok_uid=ufud_setuid(env,env->uid,ipno);
ufud.c:              //ok_gid=ufud_setgid(env,env->gid,ipno);
ufud.c:                sprintf(env->msg,"[%s] Switched to user %s!",ipno,ufud_search_user(env,env->uid,ipno));
ufud.c:                setegid(env->gid);
ufud.c:                    sprintf(env->msg,"[%s] Unknown command: %c?",ipno,b->action);
ufud.c:                  sprintf(env->msg,"[%s] 'seteuid' failed for uid %d!",ipno,env->uid);
ufud.c:                  sprintf(env->msg,"[%s] 'setegid' failed for gid %d!",ipno,env->gid);
ufud.c:              sprintf(env->msg,"[%s] Sending back errormessage.",ipno);
ufud.c:          sprintf(env->msg,"[%s] Terminating pid %d.",ipno,pid);
ufud.c:          sprintf(env->msg,"[%s] Normal disconnection.",ipno);
ufud.c:          sprintf(env->msg,"[%s] Host %s has left the building!",ipno,ipname);
ufud.c:          sprintf(env->msg,"[%s] %s is not allowed to connect!",ipno,ipname);
ufud.c:          sprintf(env->msg,"[%s] Allocating buffer (%d bytes) for error transfer",ipno,sizeof(struct s_buffer));
ufud.c:          sprintf(env->msg,"[%s] Sending back errormessage.",ipno);
ufud.com.c:      time_inout=env->timein;
ufud.com.c:      time_retry=env->timein_retry;
ufud.com.c:      time_inout=env->timeout;
ufud.com.c:      time_retry=env->timeout_retry;
ufud.com.c:      sprintf(env->msg,"[%s] Error in polling, quitting!",ipno);
ufud.com.c:        sprintf(env->msg,"[%s] Timeout in polling! (>%dms)",ipno,time_inout);
ufud.com.c:          sprintf(env->msg,"[%s] Retrying poll, left: %d",ipno,time_retry-c-1);
ufud.com.c:          sprintf(env->msg,"[%s] Timeout in polling, quitting!",ipno);
ufud.com.c:            sprintf(env->msg,"[%s] Poll: Error!",ipno);
ufud.com.c:            sprintf(env->msg,"[%s] Poll: Hang up!",ipno);
ufud.com.c:            sprintf(env->msg,"[%s] Poll: Invalid request!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] Error in polling, quitting!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EACCES] No write permission!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EAGAIN] (Non-)blocking socket issue!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EBADF] Invalid descriptor!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ECONNRESET] Connection reset by pear!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EDESTADDRREQ] No connection!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EFAULT] Invalid user space address!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EINTR] Signalled before data transmission!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EINVAL] Invalid argument!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EMSGSIZE] Invalid size!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EISCONN] Already connected!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOBUFS] Output queue is full!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOMEM] Out of memory!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOTCONN] Not connected!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOTSOCK] Argument is not a socket!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EOPNOTSUPP] Inappropriate flags!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EPIPE] End socket closed!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] Errno %d: Unknow error!",ipno,errmsg);
ufud.com.c:          sprintf(env->msg,"[%s] [EAGAIN] (Non-)blocking socket issue!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EBADF] Invalid descriptor!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ECONNREFUSED] Connection refused!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EFAULT] Invalid user space address!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EINTR] Receive interupted!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [EINVAL] Invalid argument!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOMEM] Out of memory!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOTCONN] Socket not connected!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] [ENOTSOCK] Argument is not a socket!",ipno);
ufud.com.c:          sprintf(env->msg,"[%s] Errno %d: Unknow error!",ipno,errmsg);
ufud.com.c:  sprintf(env->msg,"%s",env->msg);
ufud.com.c:      sprintf(env->msg,"[%s] Received length  : %d",ipno,len);
ufud.com.c:      sprintf(env->msg,"[%s] Received action  : %d (%s)",ipno,b->action,act);
ufud.com.c:      sprintf(env->msg,"[%s] Received username: %s",ipno,b->username);
ufud.com.c:          sprintf(env->msg,"[%s] Received dirname : %s",ipno,b->dirname);
ufud.com.c:          sprintf(env->msg,"[%s] Received dirname : %s",ipno,b->dirname);
ufud.com.c:          sprintf(env->msg,"[%s] Received filename: %s",ipno,b->filename);
ufud.com.c:      sprintf(env->msg,"[%s] Received length  : %d",ipno,len);
ufud.com.c:      sprintf(env->msg,"[%s] Received action  : %d",ipno,b->action);
ufud.com.c:      sprintf(env->msg,"[%s] Received username: %s",ipno,b->username);
ufud.com.c:          sprintf(env->msg,"[%s] Received dirname : %s",ipno,b->dirname);
ufud.com.c:          sprintf(env->msg,"[%s] Received dirname : %s",ipno,b->dirname);
ufud.com.c:          sprintf(env->msg,"[%s] Received filename: %s",ipno,b->filename);
ufud.config.c:  if((fp=fopen(env->cfgfile,"r"))!=NULL) {
ufud.config.c:    sprintf(env->msg,"Scanning config (%s)",env->cfgfile);
ufud.config.c:          env->debug=(tolower(*(line1+6))=='y');
ufud.config.c:          if(env->debug)
ufud.config.c:            sprintf(env->msg," Setting DEBUG to TRUE");
ufud.config.c:            sprintf(env->msg," Setting DEBUG to FALSE");
ufud.config.c:            env->os=UFUD_OS_LINUX;
ufud.config.c:              env->os=UFUD_OS_HPUX;
ufud.config.c:              env->os=UFUD_OS_UNKNOWN;
ufud.config.c:          switch(env->os) {
ufud.config.c:              sprintf(env->msg," Found OS (Linux).");
ufud.config.c:              sprintf(env->msg," Found OS (HP-UX).");
ufud.config.c:              sprintf(env->msg," Unknow OS? (%s).",line2);
ufud.config.c:          env->port=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found PORT (%d).",env->port);
ufud.config.c:          env->timeout=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found TIMEOUT (%d).",env->timeout);
ufud.config.c:          env->timeout_retry=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found TIMEOUT_RETRY (%d).",env->timeout_retry);
ufud.config.c:          env->timein=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found TIMEIN (%d).",env->timein);
ufud.config.c:          env->timein_retry=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found TIMEIN_RETRY (%d).",env->timein_retry);
ufud.config.c:          env->backlog=atoi(line2);
ufud.config.c:          sprintf(env->msg," Found BACKLOG (%d).",env->backlog);
ufud.config.c:          if(env->debug) {
ufud.config.c:            sprintf(env->msg," Found IP mask (%s).",line2);
ufud.config.c:    sprintf(env->msg,"End of scan.");
ufud.config.c:    env->auth_ip=(env->ipfirst!=NULL);
ufud.config.c:    sprintf(env->msg,"Configfile \"%s\" not found.",env->cfgfile);
ufud.entry.c:  env->efirst=NULL;
ufud.entry.c:  strcpy(env->dirname,b->dirname);
ufud.entry.c:  env->ndirs=0;
ufud.entry.c:  env->nfiles=0;
ufud.entry.c:  env->nlinks=0;
ufud.entry.c:  env->ntotal=0;
ufud.entry.c:  if(strlen(env->dirname)>0) {
ufud.entry.c:    sprintf(env->msg,"[%s] Reading dir %s.",ipno,env->dirname);
ufud.entry.c:    if((dirp=opendir(env->dirname))!=NULL) {
ufud.entry.c:        sprintf(env->msg,"[%s] Reading entry \"%s\".",ipno,e->fname);
ufud.entry.c:        if(env->efirst!=NULL) {
ufud.entry.c:          env->efirst=e;
ufud.entry.c:          if(S_ISDIR(e->fstat->st_mode))  env->ndirs++;
ufud.entry.c:          if(S_ISREG(e->fstat->st_mode))  env->nfiles++;
ufud.entry.c:          env->ntotal++;
ufud.entry.c:          if(S_ISLNK(e->lstat->st_mode))  env->nlinks++;
ufud.entry.c:    sprintf(env->msg,"[%s] Sending entries.",ipno);
ufud.entry.c:    e=env->efirst;
ufud.entry.c:        b->e_ndirs=env->ndirs;
ufud.entry.c:        b->e_nfiles=env->nfiles;
ufud.entry.c:        b->e_nlinks=env->nlinks;
ufud.entry.c:        b->e_ntotal=env->ntotal;
ufud.entry.c:      sprintf(env->msg,"[%s] Sending entry #%d \"%s\".",ipno,e->seqno,e->fname);
ufud.entry.c:      ufud_resize_string(env,env->dirname,36,s);
ufud.entry.c:    sprintf(env->msg,"[%s] Finished sending entries.",ipno);
ufud.entry.c:    sprintf(env->msg,"[%s] Entries given to client: %d",ipno,c);
ufud.entry.c:  strcpy(env->dirname,b->dirname);
ufud.entry.c:  if(strlen(env->dirname)>0) {
ufud.entry.c:    sprintf(env->msg,"[%s] Statting entry \"%s\".",ipno,e->fname);
ufud.entry.c:    sprintf(env->msg,"[%s] Sending entry \"%s\".",ipno,e->fname);
ufud.entry.c:      ufud_concat_dir(env,f,env->dirname,e->fname);
ufud.entry.c:      ufud_concat_dir(env,s,env->dirname,e->fname);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" opened.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] %d lines send.",ipno,i);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" closed.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" opened for writing.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] %d lines received.",ipno,i);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" closed.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] Entry \"%s\" is a file.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] Entry \"%s\" is a directory.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] Unable to unlink entry  \"%s\".",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] Entry \"%s\" unlinked.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" opened.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] %ld bytes send.",ipno,(long)i*UFUD_ACTION_BUFFER);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" closed.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" opened for writing.",ipno,f);
ufud.file.c:    sprintf(env->msg,"[%s] %ld bytes received.",ipno,(long)i*UFUD_ACTION_BUFFER);
ufud.file.c:    sprintf(env->msg,"[%s] File \"%s\" closed.",ipno,f);
ufud.id.c:    sprintf(env->msg,"Scanning users (%s)",UFUD_USR_FILE);
ufud.id.c:        sprintf(env->msg,"Unable to read entry for user %s!",u->uname);
ufud.id.c:      sprintf(env->msg," Found user \"%s\" (uid %d,gid %d)",u->uname,u->uid,u->gid);
ufud.id.c:            sprintf(env->msg,"  Unable to find password for user \"%s\"!",u->uname);
ufud.id.c:            sprintf(env->msg,"  User \"%s\" is not useable!",u->uname);
ufud.id.c:            sprintf(env->msg,"Unable to open file \"%s\"!",UFUD_USR_FILE_SHADOW);
ufud.id.c:            sprintf(env->msg,"This message will appear just this time!");
ufud.id.c:        env->ufirst=u;
ufud.id.c:    sprintf(env->msg,"Read %d users.",c);
ufud.id.c:    sprintf(env->msg,"Unable to open file \"%s\"!",UFUD_USR_FILE);
ufud.id.c:    sprintf(env->msg,"Scanning groups (%s)",UFUD_GRP_FILE);
ufud.id.c:        sprintf(env->msg,"Unable to read entry for group %s!",g->gname);
ufud.id.c:      sprintf(env->msg," Found group \"%s\" (gid %d)",g->gname,g->gid);
ufud.id.c:        env->gfirst=g;
ufud.id.c:    sprintf(env->msg,"Read %d groups.",c);
ufud.id.c:    sprintf(env->msg,"Unable to open file %s!",UFUD_GRP_FILE);
ufud.id.c:  sprintf(env->msg," Releasing users");
ufud.id.c:  u=env->ufirst;
ufud.id.c:    if(env->debug) {
ufud.id.c:      sprintf(env->msg,"  Releasing user \"%s\" (uid %d,gid %d)",u->uname,u->uid,u->gid);
ufud.id.c:  env->ufirst=NULL;
ufud.id.c:  sprintf(env->msg," Released %d users.",c);
ufud.id.c:  sprintf(env->msg," Releasing groups");
ufud.id.c:  g=env->gfirst;
ufud.id.c:    if(env->debug) {
ufud.id.c:      sprintf(env->msg,"  Releasing group \"%s\" (gid %d)",g->gname,g->gid);
ufud.id.c:  env->gfirst=NULL;
ufud.id.c:  sprintf(env->msg," Released %d groups.",c);
ufud.id.c:  u=env->ufirst;
ufud.id.c:      sprintf(env->msg,"[%s] Found user \"%s\" (%d/%d) in list.",ipno,b->username,u->uid,u->gid);
ufud.id.c:      env->uid=u->uid;
ufud.id.c:      env->gid=u->gid;
ufud.id.c:  sprintf(env->msg,"[%s] Unscrambling password.",ipno);
ufud.id.c:      sprintf(env->msg,"[%s] User \"%s\" is authorized by MD5 encryption.",ipno,b->username);
ufud.id.c:      sprintf(env->msg,"[%s] User \"%s\" is NOT authorized by MD5 encryption!",ipno,b->username);
ufud.id.c:        sprintf(env->msg,"[%s] User \"%s\" is authorized by DES encryption.",ipno,b->username);
ufud.id.c:        sprintf(env->msg,"User \"%s\" is NOT authorized by DES encryption!",b->username);
ufud.id.c:        sprintf(env->msg,"User \"%s\" is NOT authorized at all!",b->username);
ufud.id.c:    sprintf(env->msg,"[%s] User \"%s\" not found in list of users!",ipno,b->username);
ufud.id.c:  u=env->ufirst;
ufud.id.c://      if(env->debug) {
ufud.id.c://        sprintf(env->msg,"[%s] Found user %s for uid %d.",ipno,u->uname,uid);
ufud.id.c:  sprintf(env->msg,"[%s] No match for uid %d!",ipno,uid);
ufud.id.c:  g=env->gfirst;
ufud.id.c://      if(env->debug) {
ufud.id.c://        sprintf(env->msg,"[%s] Found group %s for gid %d.",ipno,g->gname,gid);
ufud.id.c:  sprintf(env->msg,"[%s] No match for gid %d!",ipno,gid);
ufud.ip.c:  if(env->ipfirst!=NULL) {
ufud.ip.c:    tmp_ip=env->ipfirst;
ufud.ip.c:    env->ipfirst=ip;
ufud.ip.c:  if(env->auth_ip) {
ufud.ip.c:    ip=env->ipfirst;
ufud.ip.c:        sprintf(env->msg,"[%s] Found match in mask %s.",ipno,ip->ipno);
ufud.ip.c:        if(env->debug) {
ufud.ip.c:          sprintf(env->msg,"[%s] No match in mask %s!",ipno,ip->ipno);
ufud.ip.c:  sprintf(env->msg," Releasing ip's.");
ufud.ip.c:  ip=env->ipfirst;
ufud.ip.c:    if(env->debug) {
ufud.ip.c:      sprintf(env->msg,"  Releasing ip \"%s\".",ip->ipno);
ufud.ip.c:  env->ipfirst=NULL;
ufud.ip.c:  sprintf(env->msg," Released %d ip's.",c);
ufud.log.c:  env->lognamefp=fopen(env->logname,"w");
ufud.log.c:  if(env->lognamefp!=NULL) {
ufud.log.c:    setbuf(env->lognamefp,NULL);
ufud.log.c:    sprintf(env->msg,"Log opened for writing.");
ufud.log.c:  if(env->lognamefp!=NULL) {
ufud.log.c:    sprintf(env->msg,"Log closed for writing.");
ufud.log.c:    fclose(env->lognamefp);
ufud.log.c:  if(env->lognamefp!=NULL) {
ufud.log.c:    fprintf(env->lognamefp,"%s: %s\n",tstamp,env->msg);
ufud.log.c:    fflush(env->lognamefp);
ufud.mem.c:  env->cfgfile=ufud_alloc_string(env,UFUD_LEN_NAME);
ufud.mem.c:  env->logname=ufud_alloc_string(env,UFUD_LEN_NAME);
ufud.mem.c:  env->dirname=ufud_alloc_string(env,UFUD_LEN_NAME);
ufud.mem.c:  env->msg=ufud_alloc_string(env,UFUD_LEN_MSG);
ufud.mem.c:  env->debug=TRUE;
ufud.mem.c:  env->ppid=0;
ufud.mem.c:  env->pid=0;
ufud.mem.c:  strcpy(env->logname,UFUD_LOGFILE);
ufud.mem.c:  strcpy(env->cfgfile,UFUD_CFGFILE);
ufud.mem.c:  env->port=UFUD_PORT;
ufud.mem.c:  env->backlog=UFUD_BACKLOG;
ufud.mem.c:  env->ufirst=NULL;
ufud.mem.c:  env->gfirst=NULL;
ufud.mem.c:  env->ipfirst=NULL;
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_usr'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_usr));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_grp'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_grp));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_ip'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_ip));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_buffer'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_buffer));
ufud.mem.c:  sprintf(env->msg,"[%s] Allocating buffer (%d bytes) for data transfer",ipno,sizeof(struct s_buffer));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_buffer_action'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_buffer_action));
ufud.mem.c:  sprintf(env->msg,"[%s] Allocating buffer (%d bytes) for data transfer",ipno,sizeof(struct s_buffer_action));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 's_entry'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct s_entry));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 'dirent'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct dirent));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for structure 'stat'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",sizeof(struct stat));
ufud.mem.c:    sprintf(env->msg,"Unable to allocate memory for datatype 'char'!");
ufud.mem.c:    sprintf(env->msg,"Needed: %d bytes.",(sizeof(char)*len)+1);
ufud.mem.c:  sprintf(env->msg,"Releasing global environment.");
ufud.mem.c:  ufud_free_string(env,env->cfgfile);
ufud.mem.c:  ufud_free_string(env,env->logname);
ufud.mem.c:  ufud_free_string(env,env->dirname);
ufud.mem.c:  sprintf(env->msg,"End of release.");
ufud.mem.c:  ufud_free_string(env,env->msg);
ufud.mem.c:  sprintf(env->msg,"[%s] Freeing transfer buffer.",ipno);
ufud.mem.c:  sprintf(env->msg,"[%s] Freeing transfer buffer.",ipno);
ufud.mem.c:  sprintf(env->msg,"[%s] Releasing panel %s.",ipno,env->dirname);
ufud.mem.c:  e=env->efirst;
ufud.mem.c:  if(env->debug) {
ufud.mem.c:    sprintf(env->msg,"[%s] Releasing entry \"%s\".",ipno,e->fname);
ufud.misc.c:  strcpy(env->msg,asctime(localtime(&result)));
ufud.misc.c:  env->msg[strlen(env->msg)-1]='\0';
ufud.misc.c:  strcpy(env->msg,ctime(timestamp));
ufud.misc.c:  env->msg[strlen(env->msg)-1]='\0';
ufud.misc.c:  sprintf(env->msg,"[%s] Setting uid to %d.",ipno,uid);
ufud.misc.c:  ok=(seteuid(env->uid)==0);
ufud.misc.c:        sprintf(env->msg,"[%s] Not supported by the implementation",ipno);
ufud.misc.c:        sprintf(env->msg,"No appropriate privileges");
ufud.misc.c:  sprintf(env->msg,"Setting gid to %d",gid);
ufud.misc.c:  ok=(setegid(env->gid)==0);
ufud.misc.c:        sprintf(env->msg,"[%s] Not supported by the implementation",ipno);
ufud.misc.c:        sprintf(env->msg,"No appropriate privileges");
ufud.version.c:  switch(env->os) {
ufud.version.c:  sprintf(env->msg,"[%s] Send data \"%s\".",ipno,UFUD_VERSION);
